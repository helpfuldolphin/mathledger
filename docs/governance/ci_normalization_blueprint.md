# CI Normalization Blueprint

**Author**: MANUS-G (CI/Governance Systems Architect)
**Status**: DRAFT

## 1. Overview

This document provides a comprehensive blueprint for normalizing the Continuous Integration (CI) infrastructure of the MathLedger project. The goal is to establish consistency, reduce maintenance overhead, and improve the reliability and readability of all GitHub Actions workflows. This blueprint addresses four key areas: workflow naming, action versioning, artifact retention, and dependency management.

Adherence to this blueprint is mandatory for all new and existing workflows.

## 2. Workflow Naming Consistency

To bring order to the `.github/workflows/` directory, all workflow filenames MUST follow a standardized naming convention.

### Convention

Workflows are categorized by their primary function. The filename format is:

`[category]-[subject].yml`

- **`[category]`**: The primary function of the workflow. Common categories include:
    - `gate`: For workflows that block PR merges based on quality checks.
    - `ops`: For operational tasks like deployment, release, or data migration.
    - `report`: For workflows that generate reports or summaries.
    - `build`: For core compilation and dependency installation tasks.

- **`[subject]`**: The specific area the workflow operates on (e.g., `curriculum-drift`, `determinism`, `api-docs`).

### Examples

| Old Name                      | New Name                          | Category | Subject             |
|-------------------------------|-----------------------------------|----------|---------------------|
| `ci.yml`                      | `build-main.yml`                  | `build`  | `main`              |
| `determinism-gate.yml`        | `gate-determinism.yml`            | `gate`   | `determinism`       |
| `evidence-gate.yml`           | `gate-evidence.yml`               | `gate`   | `evidence`          |
| `db-migration-check.yml`      | `gate-db-migration.yml`           | `gate`   | `db-migration`      |
| `notify.yml`                  | `report-notifications.yml`        | `report` | `notifications`     |

This convention makes it easy to understand a workflow's purpose at a glance and to group related workflows.

---

## 3. Action Version Unification

To prevent subtle bugs and ensure reproducibility, all workflows MUST use unified, pinned versions of third-party GitHub Actions. Relying on floating tags like `@v3` or `@main` introduces risk, as breaking changes can be introduced without warning.

### Policy

1.  **Pin to Full SHA**: All `uses:` clauses for third-party actions MUST be pinned to a specific commit SHA.
    - **Example (Bad)**: `uses: actions/checkout@v4`
    - **Example (Good)**: `uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1`

2.  **Centralized Version Management**: A new file, `/.github/actions-versions.yml`, will be created to serve as the single source of truth for all action versions. Workflows will reference versions from this file.

### Implementation

**1. Create `/.github/actions-versions.yml`:**

```yaml
# /.github/actions-versions.yml
# Single source of truth for third-party action versions.
# All versions are pinned to a specific commit SHA for security and reproducibility.

actions/checkout: b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
actions/setup-python: 82c7e631bb3cdc910f68e0081d67478d79c6982d # v5.1.0
astral-sh/setup-uv: 348518c8b83c152a4b1d3a5d93d5c1a2247b19c8 # v1.1.1
actions/upload-artifact: 5d5d22a31266ced268874388b861e4b58bb5c2f3 # v4.3.1
actions/github-script: 7d59338012a23d5b36335392f44873b6a337b5b5 # v7.0.1
```

**2. Update Workflows to Use Centralized Versions:**

Workflows will need to be updated to read from this file. This can be done using a preliminary setup job.

```yaml
jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      versions: ${{ steps.get_versions.outputs.data }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
      - name: Read action versions
        id: get_versions
        uses: mikefarah/yq@v4.43.1
        with:
          cmd: yq -o=json "." .github/actions-versions.yml

  my-job:
    needs: setup
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@${{ fromJson(needs.setup.outputs.versions)["actions/checkout"] }}

      - name: Set up Python
        uses: actions/setup-python@${{ fromJson(needs.setup.outputs.versions)["actions/setup-python"] }}
```

This approach centralizes version management, making updates and audits trivial.

---

## 4. Artifact Retention Rules

To manage costs and prevent clutter, a standardized policy for artifact retention is required.

### Policy

- **Default Retention**: All artifacts generated by pull request workflows will have a retention period of **7 days**. This is sufficient for debugging and review without storing data indefinitely.
- **Release Artifacts**: Artifacts generated by release workflows (e.g., tagged releases on the `main` branch) will have a retention period of **365 days**.
- **Critical Governance Artifacts**: Certain critical artifacts, such as sealed evidence packs or governance snapshots, MAY be stored for longer periods if required for compliance, but this should be explicitly justified.

### Implementation

All `actions/upload-artifact` steps MUST include the `retention-days` parameter.

**Example (PR Workflow):**

```yaml
- name: Upload Drift Report
  uses: actions/upload-artifact@5d5d22a31266ced268874388b861e4b58bb5c2f3 # v4.3.1
  with:
    name: drift-report
    path: artifacts/drift/drift_report.json
    retention-days: 7
```

**Example (Release Workflow):**

```yaml
- name: Upload Release Binary
  if: startsWith(github.ref, 'refs/tags/')
  uses: actions/upload-artifact@5d5d22a31266ced268874388b861e4b58bb5c2f3 # v4.3.1
  with:
    name: release-binary
    path: dist/my-app
    retention-days: 365
```

---

## 5. Cross-Job Dependency Normalization

To create clear and efficient execution graphs, dependencies between jobs (`needs`) MUST be managed explicitly and logically.

### Policy

1.  **Explicit Dependencies**: Avoid implicit dependencies. If `job-B` requires an artifact from `job-A`, it MUST declare `needs: job-A`.
2.  **Parallelize Where Possible**: Jobs that do not depend on each other should run in parallel to minimize workflow duration.
3.  **Use `outputs` for Data Passing**: Pass small pieces of data between jobs using `jobs.<job_id>.outputs`. This is more efficient and explicit than passing data via artifacts.
4.  **Fail-Fast Principle**: Jobs that perform quick sanity checks (e.g., linting, code formatting) should run first. If they fail, the entire workflow should be canceled to save resources.

### Example

Consider a workflow that builds, tests, and deploys an application.

**Bad Practice (Sequential, inefficient):**

```yaml
jobs:
  lint:
    ...
  test:
    needs: lint
    ...
  build:
    needs: test
    ...
  deploy:
    needs: build
    ...
```

**Good Practice (Parallelized, fail-fast):**

```yaml
jobs:
  lint:
    # Runs first and is fast
    ...
  test:
    # Runs in parallel with lint
    ...
  build:
    # Depends on both lint and test passing
    needs: [lint, test]
    ...
  deploy:
    # Only runs after a successful build
    needs: build
    if: github.ref == 'refs/heads/main'
    ...
```

By adhering to this blueprint, the MathLedger CI system will become more robust, maintainable, and secure. All engineers are expected to follow these guidelines for any changes to the `.github/workflows/` directory.
