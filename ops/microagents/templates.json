{
  "$schema": "https://mathledger.dev/schemas/mdap-templates-v1.json",
  "version": "1.0.0",
  "description": "MDAP Micro-Agent Template Catalog for MathLedger",
  "generated_at": "2025-11-25T00:00:00Z",

  "_status": "PHASE II TOOLING ONLY - NOT USED IN EVIDENCE PACK V1",
  "_disclaimer": "These templates define future micro-agent infrastructure. No MDAP execution engine exists yet. Phase I experiments (FO, Dyno) used fo_harness.py and rfl/runner.py directly.",
  "_rfl_log_clarification": "New RFL logs (e.g., fo_rfl.jsonl) may exist on disk. MDAP does not consume these logs. Phase I uses no micro-agents, regardless of log contents. The existence of additional RFL cycles does not activate any MDAP engine or imply any MDAP readiness.",

  "micro_task_types": {

    "hash_normalization_fix": {
      "id": "hash_normalization_fix",
      "category": "cryptographic_integrity",
      "description": "Route statement hashing through canonical normalization helper",
      "applicable_files": [
        "backend/**/*.py",
        "tests/**/*.py"
      ],
      "prompt_template": {
        "system_context": "You are a micro-agent applying a single, targeted fix to MathLedger code. All statement hashing MUST use the canonical `hash_statement()` function from `backend.crypto.hashing` which applies domain separation (DOMAIN_STMT = 0x02) and normalization.",
        "task_instruction": "Locate the hash call at {{file}}:{{line_number}} and replace the direct SHA-256 call with the canonical helper.\n\nContext:\n```python\n{{code_context}}\n```\n\nError/Test message (if any): {{error_message}}\n\nConstraints:\n- Change at most ONE line of code\n- Do NOT modify imports in this step (separate micro-task)\n- Do NOT change function signatures\n- Preserve indentation exactly\n- The replacement must use `hash_statement(normalized_text)` from `backend.crypto.hashing`",
        "expected_pattern": "sha256_hex\\(|hashlib.sha256\\(",
        "replacement_pattern": "hash_statement("
      },
      "output_schema": {
        "type": "object",
        "required": ["patch_type", "file", "line_number", "old_line_fragment", "new_line", "explanation"],
        "properties": {
          "patch_type": {
            "type": "string",
            "enum": ["single_line_edit"],
            "description": "Must be 'single_line_edit' for this micro-task type"
          },
          "file": {
            "type": "string",
            "pattern": "^(backend|tests)/.*\\.py$",
            "description": "Relative path to the file being modified"
          },
          "line_number": {
            "type": "integer",
            "minimum": 1,
            "description": "1-indexed line number of the edit"
          },
          "old_line_fragment": {
            "type": "string",
            "maxLength": 200,
            "description": "Substring of original line that will be replaced"
          },
          "new_line": {
            "type": "string",
            "maxLength": 300,
            "description": "Complete replacement line content"
          },
          "explanation": {
            "type": "string",
            "maxLength": 500,
            "description": "Brief explanation of why this change is correct"
          }
        },
        "additionalProperties": false
      },
      "red_flag_rules": [
        {"rule": "invalid_json", "description": "Output is not valid JSON"},
        {"rule": "missing_required_field", "description": "Any required field is missing"},
        {"rule": "output_too_long", "description": "explanation > 500 chars or new_line > 300 chars"},
        {"rule": "file_outside_scope", "description": "file does not match ^(backend|tests)/.*\\.py$"},
        {"rule": "multi_line_edit", "description": "new_line contains newline characters"},
        {"rule": "non_deterministic_content", "description": "Output contains timestamps, UUIDs, or random values"},
        {"rule": "import_modification", "description": "new_line modifies an import statement"},
        {"rule": "missing_domain_tag", "description": "Replacement does not use domain-separated hashing"}
      ],
      "validators": [
        {"command": "pytest tests/test_canon.py -v", "on_failure": "reject"},
        {"command": "pytest tests/test_hashing.py -v -k hash_statement", "on_failure": "reject"},
        {"command": "python -c \"from backend.crypto.hashing import hash_statement; print('OK')\"", "on_failure": "reject"}
      ],
      "mdap_config": {
        "sample_count": 5,
        "consensus_threshold": 3,
        "voting_strategy": "first_to_ahead_by_k",
        "comparison_keys": ["file", "line_number", "new_line"],
        "temperature": 0.0,
        "max_retries": 2
      }
    },

    "import_modernization_fix": {
      "id": "import_modernization_fix",
      "category": "code_hygiene",
      "description": "Replace deprecated module imports with new canonical paths",
      "applicable_files": [
        "backend/**/*.py",
        "tests/**/*.py",
        "rfl/**/*.py",
        "curriculum/**/*.py"
      ],
      "prompt_template": {
        "system_context": "You are a micro-agent updating deprecated imports. The following modules have been moved:\n- `backend.logic.canon` -> `normalization.canon`\n- `backend.logic.taut` -> `normalization.taut`\n- `backend.orchestrator.app` -> `interface.api.app`",
        "task_instruction": "Update the import statement at {{file}}:{{line_number}}.\n\nCurrent import:\n```python\n{{old_import}}\n```\n\nConstraints:\n- Change ONLY the import path, not the imported names\n- Preserve aliasing (e.g., `as normalize`)\n- Preserve relative vs absolute import style if semantically equivalent\n- Do NOT add new imports\n- Do NOT remove existing imports",
        "deprecated_paths": {
          "backend.logic.canon": "normalization.canon",
          "backend.logic.taut": "normalization.taut",
          "backend.orchestrator.app": "interface.api.app"
        }
      },
      "output_schema": {
        "type": "object",
        "required": ["patch_type", "file", "line_number", "old_line_fragment", "new_line", "explanation"],
        "properties": {
          "patch_type": {
            "type": "string",
            "enum": ["single_line_edit"]
          },
          "file": {
            "type": "string",
            "pattern": "^(backend|tests|rfl|curriculum)/.*\\.py$"
          },
          "line_number": {
            "type": "integer",
            "minimum": 1
          },
          "old_line_fragment": {
            "type": "string",
            "maxLength": 200
          },
          "new_line": {
            "type": "string",
            "maxLength": 300
          },
          "explanation": {
            "type": "string",
            "maxLength": 300
          }
        },
        "additionalProperties": false
      },
      "red_flag_rules": [
        {"rule": "invalid_json", "description": "Output is not valid JSON"},
        {"rule": "missing_required_field", "description": "Any required field is missing"},
        {"rule": "import_path_unknown", "description": "New import path is not in the known modernization map"},
        {"rule": "multi_line_edit", "description": "new_line contains newline characters"},
        {"rule": "changed_imported_names", "description": "The imported symbols changed, not just the path"},
        {"rule": "removed_import", "description": "The import was removed instead of updated"}
      ],
      "validators": [
        {"command": "python -c \"import {{new_module_path}}\"", "on_failure": "reject"},
        {"command": "python -m py_compile {{file}}", "on_failure": "reject"}
      ],
      "mdap_config": {
        "sample_count": 3,
        "consensus_threshold": 2,
        "voting_strategy": "first_to_ahead_by_k",
        "comparison_keys": ["file", "line_number", "new_line"],
        "temperature": 0.0,
        "max_retries": 1
      }
    },

    "schema_column_fallback_extraction": {
      "id": "schema_column_fallback_extraction",
      "category": "code_deduplication",
      "description": "Extract repeated schema column fallback chains into reusable helpers",
      "applicable_files": [
        "backend/axiom_engine/*.py",
        "interface/api/*.py",
        "backend/orchestrator/*.py"
      ],
      "prompt_template": {
        "system_context": "You are a micro-agent extracting repeated schema fallback patterns. The codebase uses schema-tolerant column access like:\n```python\nnormalized = (\n    data.get('normalized_text')\n    or data.get('content_norm')\n    or data.get('statement_norm')\n    or data.get('text')\n)\n```\nThese should be extracted to a helper function.",
        "task_instruction": "Extract the fallback chain at {{file}}:{{line_start}}-{{line_end}} into a call to the helper `{{helper_function_name}}`.\n\nOriginal code:\n```python\n{{original_code}}\n```\n\nConstraints:\n- Replace the fallback chain with a single function call\n- The helper function should be imported from `backend.axiom_engine.derive_utils`\n- Do NOT define the helper function in this micro-task (separate task)\n- Preserve the variable name being assigned\n- Do NOT change surrounding code",
        "helper_functions": {
          "normalized_text": "get_normalized_text",
          "success_flag": "normalize_success_flag",
          "display_text": "coalesce_display_text"
        }
      },
      "output_schema": {
        "type": "object",
        "required": ["patch_type", "file", "line_start", "line_end", "old_lines", "new_line", "helper_used", "explanation"],
        "properties": {
          "patch_type": {
            "type": "string",
            "enum": ["multi_line_collapse"]
          },
          "file": {
            "type": "string",
            "pattern": "^(backend|interface)/.*\\.py$"
          },
          "line_start": {
            "type": "integer",
            "minimum": 1
          },
          "line_end": {
            "type": "integer",
            "minimum": 1
          },
          "old_lines": {
            "type": "array",
            "items": {"type": "string"},
            "minItems": 2,
            "maxItems": 10
          },
          "new_line": {
            "type": "string",
            "maxLength": 200
          },
          "helper_used": {
            "type": "string",
            "enum": ["get_normalized_text", "normalize_success_flag", "coalesce_display_text"]
          },
          "explanation": {
            "type": "string",
            "maxLength": 400
          }
        },
        "additionalProperties": false
      },
      "red_flag_rules": [
        {"rule": "invalid_json", "description": "Output is not valid JSON"},
        {"rule": "missing_required_field", "description": "Any required field is missing"},
        {"rule": "line_range_invalid", "description": "line_end < line_start or range > 10 lines"},
        {"rule": "unknown_helper", "description": "helper_used not in allowed list"},
        {"rule": "logic_change", "description": "The semantics of the fallback chain were altered"},
        {"rule": "missing_import", "description": "The helper function import was not added (separate task)"}
      ],
      "validators": [
        {"command": "python -m py_compile {{file}}", "on_failure": "reject"},
        {"command": "pytest {{file}} -v --tb=short", "on_failure": "warn"}
      ],
      "mdap_config": {
        "sample_count": 5,
        "consensus_threshold": 3,
        "voting_strategy": "first_to_ahead_by_k",
        "comparison_keys": ["file", "line_start", "line_end", "new_line", "helper_used"],
        "temperature": 0.0,
        "max_retries": 2
      }
    },

    "success_flag_normalization": {
      "id": "success_flag_normalization",
      "category": "schema_tolerance",
      "description": "Replace inline success flag coercion with canonical helper",
      "applicable_files": [
        "backend/**/*.py",
        "interface/**/*.py"
      ],
      "prompt_template": {
        "system_context": "You are a micro-agent standardizing success flag handling. The codebase has heterogeneous success indicators (bool, int 0/1, strings 'success'/'fail'). All should use `_normalize_success_flag()` from `interface.api.app` or a local import.",
        "task_instruction": "Replace the inline success coercion at {{file}}:{{line_number}} with a call to `_normalize_success_flag()`.\n\nCurrent code:\n```python\n{{current_code}}\n```\n\nConstraints:\n- Replace the inline check with a single function call\n- Preserve the variable being assigned\n- If the function is not imported, flag this in the output\n- Do NOT add imports in this micro-task",
        "canonical_function": "_normalize_success_flag",
        "canonical_import": "from interface.api.app import _normalize_success_flag"
      },
      "output_schema": {
        "type": "object",
        "required": ["patch_type", "file", "line_number", "old_line_fragment", "new_line", "requires_import", "explanation"],
        "properties": {
          "patch_type": {
            "type": "string",
            "enum": ["single_line_edit"]
          },
          "file": {
            "type": "string",
            "pattern": "^(backend|interface)/.*\\.py$"
          },
          "line_number": {
            "type": "integer",
            "minimum": 1
          },
          "old_line_fragment": {
            "type": "string",
            "maxLength": 300
          },
          "new_line": {
            "type": "string",
            "maxLength": 200
          },
          "requires_import": {
            "type": "boolean",
            "description": "True if _normalize_success_flag is not yet imported in this file"
          },
          "explanation": {
            "type": "string",
            "maxLength": 300
          }
        },
        "additionalProperties": false
      },
      "red_flag_rules": [
        {"rule": "invalid_json", "description": "Output is not valid JSON"},
        {"rule": "missing_required_field", "description": "Any required field is missing"},
        {"rule": "multi_line_edit", "description": "new_line contains newline characters"},
        {"rule": "wrong_function_name", "description": "Used function other than _normalize_success_flag"},
        {"rule": "semantic_change", "description": "The truth table of the coercion changed"}
      ],
      "validators": [
        {"command": "python -m py_compile {{file}}", "on_failure": "reject"},
        {"command": "pytest tests/test_success_flag.py -v", "on_failure": "warn"}
      ],
      "mdap_config": {
        "sample_count": 3,
        "consensus_threshold": 2,
        "voting_strategy": "first_to_ahead_by_k",
        "comparison_keys": ["file", "line_number", "new_line"],
        "temperature": 0.0,
        "max_retries": 1
      }
    },

    "domain_tag_addition": {
      "id": "domain_tag_addition",
      "category": "cryptographic_integrity",
      "description": "Add missing domain separation tags to hash operations",
      "applicable_files": [
        "backend/**/*.py"
      ],
      "prompt_template": {
        "system_context": "You are a micro-agent ensuring cryptographic domain separation. All hash calls in MathLedger must use domain tags to prevent second preimage attacks (CVE-2012-2459).\n\nDomain tags:\n- DOMAIN_LEAF (0x00): Merkle tree leaves\n- DOMAIN_NODE (0x01): Merkle tree internal nodes\n- DOMAIN_STMT (0x02): Statement hashing\n- DOMAIN_BLCK (0x03): Block hashing",
        "task_instruction": "Add the missing domain= parameter to the hash call at {{file}}:{{line_number}}.\n\nCurrent code:\n```python\n{{current_code}}\n```\n\nContext analysis:\n- Is this hashing a statement? Use DOMAIN_STMT\n- Is this hashing a block? Use DOMAIN_BLCK\n- Is this a Merkle leaf? Use DOMAIN_LEAF\n- Is this a Merkle internal node? Use DOMAIN_NODE\n\nConstraints:\n- Add ONLY the domain= parameter\n- Do NOT change the data being hashed\n- Import the domain constant if not present (flag in output)\n- Preserve all other parameters",
        "domain_constants": {
          "DOMAIN_LEAF": "0x00 - Merkle leaves",
          "DOMAIN_NODE": "0x01 - Merkle internal nodes",
          "DOMAIN_STMT": "0x02 - Statements",
          "DOMAIN_BLCK": "0x03 - Blocks"
        }
      },
      "output_schema": {
        "type": "object",
        "required": ["patch_type", "file", "line_number", "old_line_fragment", "new_line", "domain_tag", "requires_import", "explanation"],
        "properties": {
          "patch_type": {
            "type": "string",
            "enum": ["single_line_edit"]
          },
          "file": {
            "type": "string",
            "pattern": "^backend/.*\\.py$"
          },
          "line_number": {
            "type": "integer",
            "minimum": 1
          },
          "old_line_fragment": {
            "type": "string",
            "maxLength": 200
          },
          "new_line": {
            "type": "string",
            "maxLength": 250
          },
          "domain_tag": {
            "type": "string",
            "enum": ["DOMAIN_LEAF", "DOMAIN_NODE", "DOMAIN_STMT", "DOMAIN_BLCK"]
          },
          "requires_import": {
            "type": "boolean"
          },
          "explanation": {
            "type": "string",
            "maxLength": 400
          }
        },
        "additionalProperties": false
      },
      "red_flag_rules": [
        {"rule": "invalid_json", "description": "Output is not valid JSON"},
        {"rule": "missing_required_field", "description": "Any required field is missing"},
        {"rule": "wrong_domain_tag", "description": "Domain tag does not match the semantic context"},
        {"rule": "multi_line_edit", "description": "new_line contains newline characters"},
        {"rule": "data_changed", "description": "The data being hashed was modified"},
        {"rule": "unknown_domain", "description": "domain_tag not in the allowed enum"}
      ],
      "validators": [
        {"command": "python -m py_compile {{file}}", "on_failure": "reject"},
        {"command": "pytest tests/test_hashing.py -v", "on_failure": "reject"},
        {"command": "pytest tests/test_merkle.py -v", "on_failure": "warn"}
      ],
      "mdap_config": {
        "sample_count": 5,
        "consensus_threshold": 4,
        "voting_strategy": "first_to_ahead_by_k",
        "comparison_keys": ["file", "line_number", "domain_tag", "new_line"],
        "temperature": 0.0,
        "max_retries": 2
      }
    },

    "curriculum_gate_param_fix": {
      "id": "curriculum_gate_param_fix",
      "category": "curriculum_control",
      "description": "Correct curriculum gate threshold parameters",
      "applicable_files": [
        "curriculum/**/*.py",
        "config/curriculum.yaml",
        "rfl/**/*.py"
      ],
      "prompt_template": {
        "system_context": "You are a micro-agent correcting curriculum gate parameters. RFL gates have strict validation:\n- coverage.ci_lower_min must be in (0, 1]\n- coverage.sample_min must be positive\n- abstention.max_rate_pct must be in [0, 100]\n- velocity.min_pph must be positive\n- velocity.stability_cv_max must be in [0, 1]\n- caps.backlog_max must be in [0, 1]",
        "task_instruction": "Fix the invalid gate parameter at {{file}}:{{line_number}}.\n\nCurrent value:\n```\n{{current_value}}\n```\n\nValidation error: {{validation_error}}\n\nConstraints:\n- Change ONLY the specific parameter value\n- Ensure the new value passes validation\n- Do NOT change parameter names\n- Preserve YAML formatting if applicable\n- Document the rationale for the new value",
        "gate_constraints": {
          "coverage.ci_lower_min": {"min": 0.001, "max": 1.0, "type": "float"},
          "coverage.sample_min": {"min": 1, "type": "integer"},
          "abstention.max_rate_pct": {"min": 0.0, "max": 100.0, "type": "float"},
          "abstention.max_mass": {"min": 1, "type": "integer"},
          "velocity.min_pph": {"min": 0.001, "type": "float"},
          "velocity.stability_cv_max": {"min": 0.0, "max": 1.0, "type": "float"},
          "caps.backlog_max": {"min": 0.0, "max": 1.0, "type": "float"}
        }
      },
      "output_schema": {
        "type": "object",
        "required": ["patch_type", "file", "line_number", "parameter_path", "old_value", "new_value", "explanation"],
        "properties": {
          "patch_type": {
            "type": "string",
            "enum": ["value_edit"]
          },
          "file": {
            "type": "string",
            "pattern": "^(curriculum|config|rfl)/.*\\.(py|yaml)$"
          },
          "line_number": {
            "type": "integer",
            "minimum": 1
          },
          "parameter_path": {
            "type": "string",
            "description": "Dot-separated path like 'coverage.ci_lower_min'"
          },
          "old_value": {
            "type": ["number", "string"]
          },
          "new_value": {
            "type": ["number", "string"]
          },
          "explanation": {
            "type": "string",
            "maxLength": 400
          }
        },
        "additionalProperties": false
      },
      "red_flag_rules": [
        {"rule": "invalid_json", "description": "Output is not valid JSON"},
        {"rule": "missing_required_field", "description": "Any required field is missing"},
        {"rule": "value_out_of_range", "description": "new_value does not satisfy gate constraints"},
        {"rule": "wrong_type", "description": "new_value has wrong type for this parameter"},
        {"rule": "parameter_path_unknown", "description": "parameter_path not recognized"}
      ],
      "validators": [
        {"command": "python -c \"from curriculum.gates import *; SliceGates.from_dict(...)\"", "on_failure": "reject"},
        {"command": "pytest tests/frontier/test_curriculum_gates.py -v", "on_failure": "reject"}
      ],
      "mdap_config": {
        "sample_count": 3,
        "consensus_threshold": 2,
        "voting_strategy": "first_to_ahead_by_k",
        "comparison_keys": ["file", "line_number", "parameter_path", "new_value"],
        "temperature": 0.0,
        "max_retries": 1
      }
    },

    "rfl_runner_contract_update": {
      "id": "rfl_runner_contract_update",
      "category": "interface_contract",
      "description": "Update RFL runner method signatures to match new interface contracts",
      "applicable_files": [
        "rfl/runner.py",
        "rfl/experiment.py",
        "backend/repro/*.py"
      ],
      "prompt_template": {
        "system_context": "You are a micro-agent updating RFL runner contracts. The RFLRunner and related classes have strict interface requirements for deterministic experiment reproduction.",
        "task_instruction": "Update the method signature or return type at {{file}}:{{line_number}} to match the contract.\n\nCurrent signature:\n```python\n{{current_signature}}\n```\n\nExpected contract:\n```python\n{{expected_contract}}\n```\n\nConstraints:\n- Change ONLY the signature/return type annotation\n- Do NOT change the method body\n- Preserve all decorators\n- Ensure type annotations are complete",
        "contracts": {
          "RFLRunner.run_single": "def run_single(self, run_id: int) -> ExperimentResult",
          "RFLRunner.run_with_attestation": "def run_with_attestation(self, ctx: AttestedRunContext) -> RflResult",
          "RFLExperiment.derive": "def derive(self, config: Dict[str, Any]) -> ExperimentResult"
        }
      },
      "output_schema": {
        "type": "object",
        "required": ["patch_type", "file", "line_number", "method_name", "old_signature", "new_signature", "explanation"],
        "properties": {
          "patch_type": {
            "type": "string",
            "enum": ["signature_edit"]
          },
          "file": {
            "type": "string",
            "pattern": "^(rfl|backend)/.*\\.py$"
          },
          "line_number": {
            "type": "integer",
            "minimum": 1
          },
          "method_name": {
            "type": "string"
          },
          "old_signature": {
            "type": "string",
            "maxLength": 300
          },
          "new_signature": {
            "type": "string",
            "maxLength": 300
          },
          "explanation": {
            "type": "string",
            "maxLength": 400
          }
        },
        "additionalProperties": false
      },
      "red_flag_rules": [
        {"rule": "invalid_json", "description": "Output is not valid JSON"},
        {"rule": "missing_required_field", "description": "Any required field is missing"},
        {"rule": "body_modified", "description": "Method body was changed, not just signature"},
        {"rule": "decorator_removed", "description": "A decorator was removed"},
        {"rule": "contract_mismatch", "description": "New signature does not match expected contract"}
      ],
      "validators": [
        {"command": "python -m py_compile {{file}}", "on_failure": "reject"},
        {"command": "pytest tests/rfl/ -v --tb=short", "on_failure": "warn"}
      ],
      "mdap_config": {
        "sample_count": 3,
        "consensus_threshold": 3,
        "voting_strategy": "first_to_ahead_by_k",
        "comparison_keys": ["file", "line_number", "method_name", "new_signature"],
        "temperature": 0.0,
        "max_retries": 1
      }
    },

    "api_schema_alignment": {
      "id": "api_schema_alignment",
      "category": "api_contract",
      "description": "Align API response with Pydantic schema definition",
      "applicable_files": [
        "interface/api/app.py",
        "interface/api/schemas.py",
        "backend/orchestrator/*.py"
      ],
      "prompt_template": {
        "system_context": "You are a micro-agent aligning API responses with Pydantic schemas. All FastAPI routes must return models defined in `interface.api.schemas`. Models use `extra='forbid'` so no extra fields are allowed.",
        "task_instruction": "Fix the schema mismatch at {{file}}:{{line_number}}.\n\nCurrent response construction:\n```python\n{{current_code}}\n```\n\nSchema definition:\n```python\n{{schema_definition}}\n```\n\nMismatch: {{mismatch_description}}\n\nConstraints:\n- Align field names exactly with schema\n- Use correct types (Optional, List, etc.)\n- Do NOT add fields not in schema\n- Do NOT remove required fields\n- Preserve any field validation logic",
        "schema_rules": {
          "HexDigest": "constr(pattern=r'^[0-9a-f]{64}$')",
          "extra": "forbid",
          "populate_by_name": "true"
        }
      },
      "output_schema": {
        "type": "object",
        "required": ["patch_type", "file", "line_number", "schema_name", "field_changes", "new_code", "explanation"],
        "properties": {
          "patch_type": {
            "type": "string",
            "enum": ["response_alignment"]
          },
          "file": {
            "type": "string",
            "pattern": "^(interface|backend)/.*\\.py$"
          },
          "line_number": {
            "type": "integer",
            "minimum": 1
          },
          "schema_name": {
            "type": "string",
            "description": "Name of the Pydantic model being aligned to"
          },
          "field_changes": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "field": {"type": "string"},
                "action": {"type": "string", "enum": ["add", "remove", "rename", "retype"]},
                "from": {"type": "string"},
                "to": {"type": "string"}
              }
            }
          },
          "new_code": {
            "type": "string",
            "maxLength": 500
          },
          "explanation": {
            "type": "string",
            "maxLength": 400
          }
        },
        "additionalProperties": false
      },
      "red_flag_rules": [
        {"rule": "invalid_json", "description": "Output is not valid JSON"},
        {"rule": "missing_required_field", "description": "Any required field is missing"},
        {"rule": "extra_field_added", "description": "A field not in schema was added"},
        {"rule": "required_field_removed", "description": "A required schema field was omitted"},
        {"rule": "type_mismatch", "description": "Field type does not match schema"}
      ],
      "validators": [
        {"command": "python -m py_compile {{file}}", "on_failure": "reject"},
        {"command": "pytest tests/api/ -v -k schema", "on_failure": "reject"},
        {"command": "python -c \"from interface.api.schemas import {{schema_name}}; print('OK')\"", "on_failure": "reject"}
      ],
      "mdap_config": {
        "sample_count": 5,
        "consensus_threshold": 4,
        "voting_strategy": "first_to_ahead_by_k",
        "comparison_keys": ["file", "line_number", "schema_name", "field_changes"],
        "temperature": 0.0,
        "max_retries": 2
      }
    },

    "hex64_validation_addition": {
      "id": "hex64_validation_addition",
      "category": "input_validation",
      "description": "Add 64-character hex validation to hash parameters",
      "applicable_files": [
        "backend/**/*.py",
        "interface/**/*.py"
      ],
      "prompt_template": {
        "system_context": "You are a micro-agent adding hash format validation. All statement and block hashes in MathLedger are 64-character lowercase hex strings (SHA-256). Input validation should use the HEX64 pattern: `^[a-f0-9]{64}$`",
        "task_instruction": "Add hex64 validation at {{file}}:{{line_number}} before the hash is used.\n\nCurrent code:\n```python\n{{current_code}}\n```\n\nConstraints:\n- Add validation using the HEX64 regex pattern\n- Raise appropriate exception (HTTPException for API, ValueError otherwise)\n- Do NOT modify the happy path logic\n- Validation must happen BEFORE any database or crypto operations",
        "validation_patterns": {
          "api": "if not HEX64.match(hash or ''): raise HTTPException(status_code=400, detail='Invalid hash format')",
          "internal": "if not re.match(r'^[a-f0-9]{64}$', hash or ''): raise ValueError('Invalid hash format')"
        }
      },
      "output_schema": {
        "type": "object",
        "required": ["patch_type", "file", "line_number", "validation_type", "new_lines", "explanation"],
        "properties": {
          "patch_type": {
            "type": "string",
            "enum": ["validation_insertion"]
          },
          "file": {
            "type": "string",
            "pattern": "^(backend|interface)/.*\\.py$"
          },
          "line_number": {
            "type": "integer",
            "minimum": 1
          },
          "validation_type": {
            "type": "string",
            "enum": ["api", "internal"]
          },
          "new_lines": {
            "type": "array",
            "items": {"type": "string"},
            "minItems": 1,
            "maxItems": 3
          },
          "explanation": {
            "type": "string",
            "maxLength": 300
          }
        },
        "additionalProperties": false
      },
      "red_flag_rules": [
        {"rule": "invalid_json", "description": "Output is not valid JSON"},
        {"rule": "missing_required_field", "description": "Any required field is missing"},
        {"rule": "wrong_validation_type", "description": "Used API validation in non-API code or vice versa"},
        {"rule": "validation_after_use", "description": "Validation placed after hash is used"},
        {"rule": "wrong_pattern", "description": "Regex pattern is incorrect"},
        {"rule": "wrong_exception", "description": "Exception type doesn't match context"}
      ],
      "validators": [
        {"command": "python -m py_compile {{file}}", "on_failure": "reject"},
        {"command": "pytest tests/ -v -k hash_validation", "on_failure": "warn"}
      ],
      "mdap_config": {
        "sample_count": 3,
        "consensus_threshold": 2,
        "voting_strategy": "first_to_ahead_by_k",
        "comparison_keys": ["file", "line_number", "validation_type", "new_lines"],
        "temperature": 0.0,
        "max_retries": 1
      }
    },

    "test_import_fix": {
      "id": "test_import_fix",
      "category": "test_hygiene",
      "description": "Fix broken test imports after module reorganization",
      "applicable_files": [
        "tests/**/*.py"
      ],
      "prompt_template": {
        "system_context": "You are a micro-agent fixing test imports. Tests may import from deprecated paths that need updating to the new module structure.",
        "task_instruction": "Fix the import error at {{file}}:{{line_number}}.\n\nError message:\n```\n{{error_message}}\n```\n\nCurrent import:\n```python\n{{current_import}}\n```\n\nConstraints:\n- Update ONLY the import path\n- Preserve imported names and aliases\n- Ensure the new path is valid and importable\n- Do NOT add new imports\n- Do NOT modify test logic",
        "common_fixes": {
          "backend.logic.canon": "normalization.canon",
          "backend.logic.taut": "normalization.taut",
          "backend.crypto.core": "backend.crypto.core",
          "backend.crypto.hashing": "backend.crypto.hashing"
        }
      },
      "output_schema": {
        "type": "object",
        "required": ["patch_type", "file", "line_number", "old_import", "new_import", "explanation"],
        "properties": {
          "patch_type": {
            "type": "string",
            "enum": ["single_line_edit"]
          },
          "file": {
            "type": "string",
            "pattern": "^tests/.*\\.py$"
          },
          "line_number": {
            "type": "integer",
            "minimum": 1
          },
          "old_import": {
            "type": "string",
            "maxLength": 200
          },
          "new_import": {
            "type": "string",
            "maxLength": 200
          },
          "explanation": {
            "type": "string",
            "maxLength": 300
          }
        },
        "additionalProperties": false
      },
      "red_flag_rules": [
        {"rule": "invalid_json", "description": "Output is not valid JSON"},
        {"rule": "missing_required_field", "description": "Any required field is missing"},
        {"rule": "import_still_invalid", "description": "New import path does not resolve"},
        {"rule": "names_changed", "description": "Imported names were modified"},
        {"rule": "test_logic_changed", "description": "Non-import lines were modified"}
      ],
      "validators": [
        {"command": "python -m py_compile {{file}}", "on_failure": "reject"},
        {"command": "pytest {{file}} -v --collect-only", "on_failure": "reject"}
      ],
      "mdap_config": {
        "sample_count": 3,
        "consensus_threshold": 2,
        "voting_strategy": "first_to_ahead_by_k",
        "comparison_keys": ["file", "line_number", "new_import"],
        "temperature": 0.0,
        "max_retries": 1
      }
    },

    "add_import_statement": {
      "id": "add_import_statement",
      "category": "code_hygiene",
      "description": "Add a missing import statement to a file",
      "applicable_files": [
        "backend/**/*.py",
        "interface/**/*.py",
        "tests/**/*.py",
        "rfl/**/*.py",
        "curriculum/**/*.py"
      ],
      "prompt_template": {
        "system_context": "You are a micro-agent adding a single import statement. Imports should be placed according to PEP 8: standard library, then third-party, then local imports, each group separated by a blank line.",
        "task_instruction": "Add the import statement for {{symbol}} to {{file}}.\n\nThe symbol is used at line {{usage_line}} but not imported.\n\nCanonical import:\n```python\n{{canonical_import}}\n```\n\nConstraints:\n- Add the import in the correct PEP 8 section\n- Do NOT duplicate existing imports\n- Do NOT modify any other code\n- Preserve existing import structure",
        "import_categories": {
          "standard": ["os", "sys", "re", "json", "hashlib", "typing"],
          "third_party": ["psycopg", "redis", "fastapi", "pydantic", "numpy"],
          "local": ["backend", "interface", "normalization", "curriculum", "rfl"]
        }
      },
      "output_schema": {
        "type": "object",
        "required": ["patch_type", "file", "insert_after_line", "import_statement", "category", "explanation"],
        "properties": {
          "patch_type": {
            "type": "string",
            "enum": ["import_addition"]
          },
          "file": {
            "type": "string",
            "pattern": ".*\\.py$"
          },
          "insert_after_line": {
            "type": "integer",
            "minimum": 0,
            "description": "Line number after which to insert (0 = top of file)"
          },
          "import_statement": {
            "type": "string",
            "maxLength": 200
          },
          "category": {
            "type": "string",
            "enum": ["standard", "third_party", "local"]
          },
          "explanation": {
            "type": "string",
            "maxLength": 200
          }
        },
        "additionalProperties": false
      },
      "red_flag_rules": [
        {"rule": "invalid_json", "description": "Output is not valid JSON"},
        {"rule": "missing_required_field", "description": "Any required field is missing"},
        {"rule": "duplicate_import", "description": "Import already exists in file"},
        {"rule": "wrong_category", "description": "Import placed in wrong PEP 8 section"},
        {"rule": "invalid_import", "description": "Import statement is syntactically invalid"}
      ],
      "validators": [
        {"command": "python -m py_compile {{file}}", "on_failure": "reject"},
        {"command": "python -c \"{{import_statement}}\"", "on_failure": "reject"}
      ],
      "mdap_config": {
        "sample_count": 3,
        "consensus_threshold": 2,
        "voting_strategy": "first_to_ahead_by_k",
        "comparison_keys": ["file", "import_statement", "category"],
        "temperature": 0.0,
        "max_retries": 1
      }
    }
  },

  "global_red_flags": [
    {
      "rule": "output_contains_secrets",
      "description": "Output contains API keys, passwords, or credentials",
      "severity": "critical"
    },
    {
      "rule": "output_contains_pii",
      "description": "Output contains personally identifiable information",
      "severity": "critical"
    },
    {
      "rule": "non_utf8_content",
      "description": "Output contains non-UTF-8 characters",
      "severity": "high"
    },
    {
      "rule": "output_too_large",
      "description": "Total output exceeds 10KB",
      "severity": "medium"
    },
    {
      "rule": "contains_eval_or_exec",
      "description": "Output contains eval() or exec() calls",
      "severity": "critical"
    }
  ],

  "mdap_global_config": {
    "default_sample_count": 5,
    "default_consensus_threshold": 3,
    "max_parallel_samples": 10,
    "timeout_per_sample_ms": 30000,
    "retry_on_red_flag": true,
    "log_all_samples": true,
    "comparison_equality_mode": "structural",
    "determinism_seed": 0
  },

  "phase_ii_uplift_templates": {
    "_phase_ii_banner": "PHASE II DESIGN ONLY â€” NOT IMPLEMENTED. These templates define future uplift experiment infrastructure. No current RFL logs are suitable inputs. The existence of additional RFL cycles does NOT activate any MDAP engine or imply any MDAP readiness.",

    "phase_ii_uplift_experiment": {
      "id": "phase_ii_uplift_experiment",
      "category": "uplift_orchestration",
      "description": "PHASE II ONLY: Template for orchestrating uplift experiments on non-degenerate slices",
      "status": "NOT_IMPLEMENTED",
      "requires_phase": "II",
      "requires_nondegenerate_data": true,
      "prohibits_phase_i_logs": true,

      "prohibited_log_patterns": [
        "fo_rfl.jsonl",
        "fo_rfl_50.jsonl",
        "fo_baseline.jsonl",
        "fo_baseline_50.jsonl",
        "**/evidence_pack_v1/**/*.jsonl",
        "**/phase_i/**/*.jsonl"
      ],

      "input_schema": {
        "type": "object",
        "required": ["experiment_id", "slice_name", "cycle_count", "baseline_seed", "rfl_seed", "manifest_path"],
        "properties": {
          "experiment_id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this uplift experiment"
          },
          "slice_name": {
            "type": "string",
            "description": "Target uplift slice identifier (must be non-degenerate)"
          },
          "cycle_count": {
            "type": "integer",
            "minimum": 100,
            "description": "Number of cycles to run (e.g., 1000)"
          },
          "baseline_seed": {
            "type": "integer",
            "description": "RNG seed for baseline run"
          },
          "rfl_seed": {
            "type": "integer",
            "description": "RNG seed for RFL run (typically matches baseline_seed)"
          },
          "nondegeneracy_threshold": {
            "type": "number",
            "minimum": 0.01,
            "maximum": 0.5,
            "default": 0.05,
            "description": "Minimum abstention delta to claim non-degeneracy"
          },
          "baseline_log_path": {
            "type": "string",
            "description": "OUTPUT path for baseline log (NOT a Phase I log)"
          },
          "rfl_log_path": {
            "type": "string",
            "description": "OUTPUT path for RFL log (NOT a Phase I log)"
          },
          "manifest_path": {
            "type": "string",
            "description": "Path to experiment manifest file"
          }
        },
        "additionalProperties": false
      },

      "output_schema": {
        "type": "object",
        "required": ["experiment_id", "experiment_valid", "nondegeneracy_met", "phase", "disclaimer"],
        "properties": {
          "experiment_id": {
            "type": "string"
          },
          "experiment_valid": {
            "type": "boolean",
            "description": "True only if all verification checks pass"
          },
          "nondegeneracy_met": {
            "type": "boolean",
            "description": "True only if abstention delta exceeds threshold"
          },
          "baseline_abstention_rate": {
            "type": "number",
            "minimum": 0,
            "maximum": 1
          },
          "rfl_abstention_rate": {
            "type": "number",
            "minimum": 0,
            "maximum": 1
          },
          "uplift_scalar": {
            "type": "number",
            "description": "baseline_abstention - rfl_abstention"
          },
          "confidence_interval": {
            "type": "array",
            "items": {"type": "number"},
            "minItems": 2,
            "maxItems": 2,
            "description": "95% CI for uplift_scalar"
          },
          "recommendation": {
            "type": "string",
            "enum": ["proceed", "more_data_needed", "no_uplift_detected"]
          },
          "phase": {
            "type": "string",
            "const": "II",
            "description": "MUST be 'II' - this template cannot produce Phase I claims"
          },
          "flags": {
            "type": "array",
            "items": {"type": "string"},
            "description": "Any warnings or anomalies detected"
          },
          "disclaimer": {
            "type": "string",
            "const": "Based on Phase II uplift data only. Not derived from Phase I logs.",
            "description": "MUST include this disclaimer in all outputs"
          }
        },
        "additionalProperties": false
      },

      "red_flag_rules": [
        {"rule": "phase_i_log_detected", "description": "Input log matches prohibited Phase I pattern", "severity": "critical"},
        {"rule": "missing_preregistration", "description": "No uplift_experiment_config.json found", "severity": "critical"},
        {"rule": "degenerate_baseline", "description": "Baseline abstention < 1% (no signal to measure)", "severity": "critical"},
        {"rule": "missing_disclaimer", "description": "Output lacks required Phase II disclaimer", "severity": "critical"},
        {"rule": "phase_mismatch", "description": "Output claims phase != 'II'", "severity": "critical"},
        {"rule": "confidence_interval_missing", "description": "Uplift claim without CI", "severity": "high"},
        {"rule": "seed_mismatch", "description": "Baseline and RFL seeds differ unexpectedly", "severity": "medium"}
      ],

      "validators": [
        {"command": "python -c \"import json; c=json.load(open('{{manifest_path}}')); assert c.get('phase')=='II'\"", "on_failure": "reject"},
        {"command": "python -c \"assert '{{baseline_log_path}}'.find('fo_rfl')==-1 and '{{baseline_log_path}}'.find('fo_baseline')==-1\"", "on_failure": "reject"},
        {"command": "python -c \"assert '{{rfl_log_path}}'.find('fo_rfl')==-1 and '{{rfl_log_path}}'.find('fo_baseline')==-1\"", "on_failure": "reject"}
      ],

      "mdap_config": {
        "sample_count": 1,
        "consensus_threshold": 1,
        "voting_strategy": "unanimous",
        "comparison_keys": ["experiment_id", "experiment_valid", "nondegeneracy_met", "recommendation"],
        "temperature": 0.0,
        "max_retries": 0
      },

      "implementation_notes": {
        "status": "NOT_IMPLEMENTED",
        "blocking_requirements": [
          "Non-degenerate uplift slices must be identified and validated",
          "Preregistration workflow must be established",
          "Fresh experiment infrastructure must be built (separate from Phase I)"
        ],
        "phase_i_clarification": "All existing RFL logs (fo_rfl.jsonl, fo_rfl_50.jsonl, etc.) are Phase I plumbing / negative controls. They are NOT inputs to this template and CANNOT be used to claim uplift."
      }
    }
  }
}
