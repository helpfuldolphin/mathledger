# REAL-READY UNIFIED DIFF
# File: experiments/u2/runner.py
# Purpose: Add telemetry support to U2Runner

--- a/experiments/u2/runner.py
+++ b/experiments/u2/runner.py
@@ 39,0 +40,3 @@
     slice_config: Dict[str, Any] = field(default_factory=dict)
     
+    # Telemetry parameters
+    enable_telemetry: bool = False
+    telemetry_output_path: Optional[Path] = None
+    
     # Search parameters
     max_beam_width: int = 100

@@ +427,0 @@
+
+    def _execute_with_telemetry(
+        self,
+        candidate: Any,
+        execute_fn: Callable,
+        cycle: int,
+    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
+        """
+        Execute candidate with telemetry collection.
+        
+        Args:
+            candidate: Candidate to execute
+            execute_fn: Execution function
+            cycle: Current cycle number
+        
+        Returns:
+            Tuple of (success, telemetry_dict)
+        """
+        
+        if not self.config.enable_telemetry:
+            # No telemetry - use standard execution
+            success = execute_fn(candidate)
+            return success, None
+        
+        # Import telemetry runtime
+        from backend.verification.telemetry_runtime import (
+            run_lean_with_monitoring,
+            LeanVerificationTelemetry,
+        )
+        from backend.verification.lean_executor import construct_lean_command
+        from pathlib import Path
+        
+        # Extract module/statement from candidate
+        # NOTE: This assumes candidate has 'module_name' and 'statement' attributes
+        # Adjust based on actual candidate structure
+        module_name = getattr(candidate, 'module_name', 'unknown')
+        statement = getattr(candidate, 'statement', 'unknown')
+        
+        # Construct Lean command
+        # NOTE: Adjust path construction based on actual project structure
+        module_path = Path(f"{module_name.replace('.', '/')}.lean")
+        
+        lean_command = construct_lean_command(
+            module_path=module_path,
+            timeout_s=self.config.cycle_budget_s,
+            use_lake=True,
+            trace_tactics=True,
+        )
+        
+        # Run with monitoring
+        telemetry = run_lean_with_monitoring(
+            module_name=module_name,
+            lean_command=lean_command,
+            timeout_s=self.config.cycle_budget_s,
+            verification_id=f"{self.config.experiment_id}_cycle{cycle}",
+            context=f"u2_{self.config.mode}",
+            tier="balanced",  # Default tier
+        )
+        
+        # Write telemetry to output file if configured
+        if self.config.telemetry_output_path:
+            with open(self.config.telemetry_output_path, 'a') as f:
+                f.write(telemetry.to_jsonl() + '\n')
+        
+        return telemetry.success, telemetry.to_dict()
