# REAL-READY UNIFIED DIFF
# File: backend/lean_mode.py
# Purpose: Add telemetry support function

--- a/backend/lean_mode.py
+++ b/backend/lean_mode.py
@@ +454,0 @@
+
+
+def run_lean_with_telemetry(
+    statement: str,
+    proof_body: str,
+    timeout_s: float = 60.0,
+    enable_telemetry: bool = True,
+) -> Dict[str, Any]:
+    """
+    Run Lean verification with telemetry collection.
+    
+    This function integrates with the existing lean_mode infrastructure
+    while adding comprehensive telemetry collection.
+    
+    Args:
+        statement: Lean statement to verify
+        proof_body: Lean proof body
+        timeout_s: Timeout in seconds
+        enable_telemetry: Enable telemetry collection
+    
+    Returns:
+        Dict with verification result and telemetry
+    """
+    
+    if not enable_telemetry:
+        # Use existing infrastructure without telemetry
+        build_runner = get_build_runner()
+        result = build_runner(statement, proof_body)
+        return {
+            "success": result.get("success", False),
+            "outcome": "verified" if result.get("success") else "proof_invalid",
+            "telemetry": None,
+        }
+    
+    # Import telemetry runtime
+    from backend.verification.telemetry_runtime import (
+        run_lean_with_monitoring,
+        LeanVerificationTelemetry,
+    )
+    from backend.verification.lean_executor import construct_lean_command
+    
+    # Create temporary Lean file
+    import tempfile
+    from pathlib import Path
+    
+    with tempfile.NamedTemporaryFile(
+        mode='w',
+        suffix='.lean',
+        delete=False,
+    ) as f:
+        # Write Lean theorem
+        f.write(f"theorem test_statement : {statement} := by\n")
+        f.write(proof_body)
+        f.write("\n")
+        temp_path = Path(f.name)
+    
+    try:
+        # Construct Lean command
+        lean_command = construct_lean_command(
+            module_path=temp_path,
+            timeout_s=timeout_s,
+            use_lake=False,  # Use standalone lean for temp files
+            trace_tactics=True,
+        )
+        
+        # Run with monitoring
+        telemetry = run_lean_with_monitoring(
+            module_name=f"temp_{statement[:20]}",
+            lean_command=lean_command,
+            timeout_s=timeout_s,
+            verification_id=f"lean_mode_{int(time.time())}",
+            context="lean_mode",
+        )
+        
+        return {
+            "success": telemetry.success,
+            "outcome": telemetry.outcome,
+            "telemetry": telemetry.to_dict(),
+        }
+    
+    finally:
+        # Clean up temp file
+        if temp_path.exists():
+            temp_path.unlink()
