--- a/backend/logic/canon.py
+++ b/backend/logic/canon.py
@@ -1,14 +1,14 @@
-"""Canonicalization for propositional logic.
-
-normalize(): compact, no-spaces canonical form used by engine & most tests.
-normalize_pretty(): human-friendly spacing for arrows/parentheses used by
-mp_derivation tests.
-
-Rules (normalize compact):
-- Unicode map: → ->, ∧ -> /\, ∨ -> \/, ¬ -> ~
-- Top-level '->': preserve LEFT association; flatten only the RIGHT chain.
-- '/\' and '\/' are commutative + idempotent (flatten, sort, dedupe).
-- Under top-level OR, wrap AND/IMP children with parentheses so:
-  (p/\q)\/(q/\p) is produced. (We preserve AND child order under OR.)
-- Canon special: "(p -> q) -> r" => "(p->q)->r"
-"""
+"""Canonicalization for propositional logic.
+
+Provides two normalization modes:
+- `normalize()`: compact, no-spaces canonical form for engine & tests
+- `normalize_pretty()`: human-friendly spacing for MP derivation displays
+
+Operator tokens: `->` (implication), `/\\` (AND), `\\/` (OR), `~` (negation)
+
+Key invariants:
+- Left-associative implication: `p->q->r` becomes `p->(q->r)`
+- AND/OR are commutative + idempotent (flatten, sort, dedupe)
+- Under OR, wrap AND/IMP children: `(p/\\q)\\/(q/\\p)`
+- Whitespace: compact (no spaces) vs pretty (spaced arrows)
+"""
 import re
 from typing import List, Set, Tuple, Optional

@@ -24,6 +24,7 @@ OP_OR  = "\\/"
 OPS = [OP_IMP, OP_AND, OP_OR]

 # ---------- helpers ----------
+"""Map Unicode operators to ASCII tokens."""
 def _map_unicode(s: str) -> str:
     return (s.replace("→", OP_IMP)
              .replace("∧", OP_AND)
@@ -31,9 +32,11 @@ def _map_unicode(s: str) -> str:
              .replace("¬", "~"))

+"""Normalize whitespace to single spaces."""
 def _strip_spaces(s: str) -> str:
     return re.sub(r"\s+", " ", s.strip())

+"""Remove all whitespace for compact form."""
 def _rm_spaces_all(s: str) -> str:
     return s.replace(" ", "")

+"""Check if string is entirely wrapped in parentheses."""
 def _entire_wrapped(s: str) -> bool:
     if not s or s[0] != "(" or s[-1] != ")":
         return False
@@ -46,6 +49,7 @@ def _entire_wrapped(s: str) -> bool:
                 return False
     return True

+"""Remove outer parentheses if entire string is wrapped."""
 def _strip_outer_parens(s: str) -> str:
     while _entire_wrapped(s):
         s = s[1:-1].strip()
@@ -53,6 +57,7 @@ def _strip_outer_parens(s: str) -> str:
     return s

+"""Split string at top-level operator, respecting parentheses."""
 def _split_top(s: str, op: str) -> Tuple[Optional[str], Optional[str]]:
     s = s.strip()
     depth = 0; w = len(op); i = 0; L = len(s)
@@ -68,6 +73,7 @@ def _split_top(s: str, op: str) -> Tuple[Optional[str], Optional[str]]:
         i += 1
     return None, None

+"""Flatten nested operator chains into list of operands."""
 def _flatten_collect(s: str, op: str) -> List[str]:
     s = _strip_outer_parens(s)
     a, b = _split_top(s, op)
@@ -76,9 +82,11 @@ def _flatten_collect(s: str, op: str) -> List[str]:
     return _flatten_collect(a, op) + _flatten_collect(b, op)

+"""Check if string contains logical operators."""
 def _has_op(t: str) -> bool:
     return any(op in t for op in OPS) or ("~" in t and len(t) > 2)

+"""Wrap OR child in parentheses if it contains AND/IMP operators."""
 def _wrap_or_child(t: str) -> str:
     # Under OR, wrap children that contain AND or IMP to keep expected structure.
     if OP_AND in t or OP_IMP in t:
@@ -86,6 +94,7 @@ def _wrap_or_child(t: str) -> str:
     return t

+"""Normalize child under OR without re-sorting top-level AND operands."""
 def _normalize_under_or_child(s: str) -> str:
     """Normalize a child under a top-level OR without re-sorting a top-level AND."""
     s = _map_unicode(s)
@@ -130,6 +139,7 @@ def _normalize_under_or_child(s: str) -> str:
 # ----------------------------
 # normalize (compact / engine)
 # ----------------------------
+"""Convert propositional formula to compact canonical form.
+
+Examples: `p->q->r` -> `p->(q->r)`, `p/\\q/\\p` -> `p/\\q`
+"""
 def normalize(s: str) -> str:
     original = s

@@ -221,6 +231,7 @@ def are_equivalent(a: str, b: str) -> bool:
     return normalize(a) == normalize(b)

+"""Extract atomic proposition names from formula."""
 def get_atomic_propositions(s: str) -> Set[str]:
     return set(re.findall(r"[A-Za-z][A-Za-z0-9_]*", _map_unicode(s)))

@@ -228,6 +239,7 @@ def get_atomic_propositions(s: str) -> Set[str]:
 # ---------------------------------
 # normalize_pretty (for MP displays)
 # ---------------------------------
+"""Convert to human-friendly form with spaced arrows.
+
+Examples: `p->q->r` -> `p -> (q -> r)`, `(p->q)->r` -> `(p -> q) -> r`
+"""
 def normalize_pretty(s: str) -> str:
     """Return human-friendly spaced arrows for MP display tests:
        - 'p -> q -> r'  => 'p -> (q -> r)'
--- a/backend/axiom_engine/rules.py
+++ b/backend/axiom_engine/rules.py
@@ -1,4 +1,4 @@
-"""Test-facing rules helpers for propositional MP: Statement + ModusPonens with strict semantics."""
+"""Test-facing rules helpers for propositional MP: Statement + ModusPonens with strict semantics.
+
+Provides Statement class for normalized logic formulas and ModusPonens inference engine.
+"""
 from dataclasses import dataclass, field
 from typing import Optional, List, Set, Tuple
@@ -5,6 +5,7 @@ from typing import Optional, List, Set, Tuple
 def _strip_outer(s: str) -> str:
+    """Remove outer parentheses if string is entirely wrapped."""
     s = s.strip()
     if not s: return s
     if s[0] != "(" or s[-1] != ")": return s
@@ -19,6 +20,7 @@ def _strip_outer(s: str) -> str:
     return s[1:-1].strip()

 def _split_top_impl(s: str) -> Tuple[Optional[str], Optional[str]]:
+    """Split implication at top-level -> operator, respecting parentheses."""
     s = s.strip(); depth = 0; i = 0
     while i < len(s) - 1:
         ch = s[i]
@@ -33,9 +35,11 @@ def _split_top_impl(s: str) -> Tuple[Optional[str], Optional[str]]:
         i += 1
     return (None, None)

+"""Check if statement is an implication (contains top-level ->)."""
 def _is_implication(stmt: str) -> bool:
     a, b = _split_top_impl(stmt); return a is not None and b is not None

+"""Parse implication into antecedent and consequent."""
 def _parse_implication(stmt: str) -> Tuple[Optional[str], Optional[str]]:
     a, b = _split_top_impl(stmt)
     if a is None or b is None: return (None, None)
@@ -42,6 +46,9 @@ def _parse_implication(stmt: str) -> Tuple[Optional[str], Optional[str]]:
     return (_strip_outer(a), _strip_outer(b))

 @dataclass
+"""Represents a logical statement with normalization and derivation metadata.
+
+Examples: `Statement("p->q", is_axiom=True)`, `Statement("r", parent_statements=["p", "p->q"])`
+"""
 class Statement:
     text: str
     is_axiom: bool = False
@@ -50,6 +57,7 @@ class Statement:
     parent_statements: List[str] = field(default_factory=list)
     keep_text_content: bool = False  # NEW: for DB rows that should expose original text

+    """Return normalized content using canon.normalize() or fallback to stripped text."""
     @property
     def content(self) -> str:
         if self.keep_text_content:
@@ -60,6 +68,9 @@ class Statement:
         except Exception:
             return _strip_outer(self.text).replace(" ", "")

+"""Modus Ponens inference engine for propositional logic.
+
+Applies MP rule: from `p` and `p->q`, derive `q`. Records parent statements.
+"""
 class ModusPonens:
     _parse_implication = staticmethod(_parse_implication)
     _is_implication = staticmethod(_is_implication)
@@ -67,6 +78,7 @@ class ModusPonens:
     @staticmethod
+    """Check if MP can be applied to exactly 2 premises."""
     def can_apply(premises: List[Statement]) -> bool:
         if len(premises) != 2: return False
         try:
@@ -81,6 +93,7 @@ class ModusPonens:
         return False

     @staticmethod
+    """Apply MP to premises, return derived statements with parent tracking."""
     def apply(premises: List[Statement]) -> List[Statement]:
         if len(premises) != 2: return []
         try:
@@ -106,6 +119,7 @@ class ModusPonens:
         return uniq

+"""Apply MP to set of statements, return new derivations."""
 def apply_modus_ponens(statements: Set[str]) -> Set[str]:
     try:
         from backend.logic.canon import normalize
