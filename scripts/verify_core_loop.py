#!/usr/bin/env python3
"""
Core Loop Determinism Verifier
==============================

One command proves the MathLedger core loop is deterministic WITH REAL LEAN.

CORE LOOP (Lean-coupled):
    (statement) → (Lean verifies) → (proof artifacts) → (R_t, U_t) → H_t = SHA256(R_t || U_t)

This script:
    1. Verifies Lean toolchain is available (fails loudly if not)
    2. Runs the REAL Lean-backed pipeline TWICE with identical inputs
    3. Computes H_t from REAL Lean verification artifacts
    4. Compares H_t from both runs to prove determinism
    5. Emits a single JSON verdict to stdout

LEAN REQUIREMENT:
    By default, this script requires a working Lean installation.
    If Lean is not installed, it will FAIL with a clear error message.

    To run in mock mode (for testing without Lean):
        ML_LEAN_MODE=mock python scripts/verify_core_loop.py

IMPORTANT:
    In "enabled" mode, H_t is computed from REAL Lean artifacts:
        R_t = SHA256(lean_source || stdout_hash || stderr_hash || returncode)
        U_t = SHA256(ui_event_payload)
        H_t = SHA256(R_t || U_t)

    In "mock" mode, H_t is computed from synthetic artifacts (no real Lean).

Usage:
    python scripts/verify_core_loop.py
    python scripts/verify_core_loop.py --seed 42
    python scripts/verify_core_loop.py --runs 5 --verbose

Exit codes:
    0 = deterministic (all H_t values match, Lean ran)
    1 = non-deterministic (H_t mismatch detected)
    2 = error during execution (including Lean unavailable)
"""

from __future__ import annotations

import argparse
import hashlib
import json
import os
import pathlib
import sys
import time
import traceback
from dataclasses import dataclass
from typing import Any, Dict, List, Optional


# Default Lean project directory
DEFAULT_LEAN_PROJECT_DIR = r"C:\dev\mathledger\backend\lean_proj"

# Test statements for verification (deterministic set)
TEST_STATEMENTS = [
    "p -> p",
    "p -> (q -> p)",
    "(p -> q) -> (p -> q)",
]


def get_lean_project_dir() -> str:
    """Get the Lean project directory."""
    return os.environ.get("LEAN_PROJECT_DIR", DEFAULT_LEAN_PROJECT_DIR)


def ensure_jobs_dir() -> str:
    """Ensure the Jobs directory exists for Lean job files."""
    project_dir = pathlib.Path(get_lean_project_dir())
    ml_dir = project_dir / "ML"
    jobs_dir = ml_dir / "Jobs"
    jobs_dir.mkdir(parents=True, exist_ok=True)

    jobs_mod = ml_dir / "Jobs.lean"
    if not jobs_mod.exists():
        jobs_mod.write_text(
            "namespace ML.Jobs\nend ML.Jobs\n",
            encoding="utf-8",
            newline="\n",
        )

    return str(jobs_dir)


def verify_lean_available() -> Dict[str, Any]:
    """
    Verify Lean toolchain is available and return status.

    Returns:
        Dictionary with lean status information
    """
    from backend.lean_mode import (
        LeanMode,
        LeanToolchainUnavailableError,
        get_lean_status,
    )

    try:
        status = get_lean_status()
        return {
            "available": status.lean_available,
            "configured_mode": status.configured_mode.value,
            "effective_mode": status.effective_mode.value,
            "is_mock": status.is_mock,
            "error": None,
        }
    except LeanToolchainUnavailableError as e:
        return {
            "available": False,
            "configured_mode": "full",
            "effective_mode": None,
            "is_mock": False,
            "error": str(e),
        }


@dataclass(frozen=True)
class LeanVerificationResult:
    """Result of a single Lean verification."""
    statement: str
    job_id: str
    module_name: str
    lean_source: str
    lean_source_hash: str
    returncode: int
    stdout: str
    stderr: str
    stdout_hash: str
    stderr_hash: str
    duration_ms: int
    success: bool
    is_mock: bool


@dataclass(frozen=True)
class LeanCoupledPipelineResult:
    """
    Result of Lean-coupled pipeline run.

    H_t is computed from REAL Lean artifacts when lean_ran=True.
    """
    # Lean verification details
    lean_results: List[LeanVerificationResult]
    lean_ran: bool

    # Dual-root attestation (Lean-coupled)
    R_t: str  # Reasoning root - from Lean artifacts
    U_t: str  # UI root - from UI event
    H_t: str  # Composite root = SHA256(R_t || U_t)

    # UI event details
    ui_event_hash: str

    # Run metadata
    seed: int
    run_id: str


def generate_lean_source(job_id: str, statement: str) -> str:
    """Generate deterministic Lean source for a statement."""
    # Map statements to proof tactics
    proof_tactics = {
        "p -> p": "  intro hp\n  exact hp",
        "p -> (q -> p)": "  intro hp\n  intro _\n  exact hp",
        "(p -> q) -> (p -> q)": "  intro hpq\n  exact hpq",
    }

    tactic = proof_tactics.get(statement, "  intro hp\n  exact hp")

    return f"""import Mathlib

namespace ML.Jobs

/-- Auto-generated by verify_core_loop for job {job_id} -/
set_option linter.unusedVariables false
theorem job_{job_id} (p q r s t : Prop) : {statement} := by
{tactic}

end ML.Jobs
"""


def run_lean_verification_single(
    statement: str,
    jobs_dir: str,
    project_dir: str,
    build_runner,
    is_mock_check,
) -> LeanVerificationResult:
    """
    Run Lean verification on a single statement.

    Returns verification result with all artifacts needed for R_t computation.
    """
    # Generate deterministic job ID from statement
    stmt_hash = hashlib.sha256(statement.encode("utf-8")).hexdigest()
    jid = stmt_hash[:12]
    module_name = f"ML.Jobs.job_{jid}"
    job_file = pathlib.Path(jobs_dir) / f"job_{jid}.lean"

    # Generate Lean source
    lean_source = generate_lean_source(jid, statement)
    lean_source_hash = hashlib.sha256(lean_source.encode("utf-8")).hexdigest()

    try:
        # Write job file
        job_file.write_text(lean_source, encoding="utf-8", newline="\n")

        # Run Lean verification
        start = time.perf_counter()
        result = build_runner(module_name)
        duration_ms = int((time.perf_counter() - start) * 1000)

        stdout = result.stdout or ""
        stderr = result.stderr or ""
        stdout_hash = hashlib.sha256(stdout.encode("utf-8")).hexdigest()
        stderr_hash = hashlib.sha256(stderr.encode("utf-8")).hexdigest()

        is_mock = is_mock_check(stderr)

        return LeanVerificationResult(
            statement=statement,
            job_id=jid,
            module_name=module_name,
            lean_source=lean_source,
            lean_source_hash=lean_source_hash,
            returncode=result.returncode,
            stdout=stdout,
            stderr=stderr,
            stdout_hash=stdout_hash,
            stderr_hash=stderr_hash,
            duration_ms=duration_ms,
            success=result.returncode == 0,
            is_mock=is_mock,
        )

    finally:
        # Cleanup
        try:
            job_file.unlink(missing_ok=True)
        except Exception:
            pass


def compute_reasoning_root(lean_results: List[LeanVerificationResult]) -> str:
    """
    Compute R_t (reasoning root) from Lean verification artifacts.

    R_t = SHA256(concat(sorted([
        SHA256(lean_source_hash || stdout_hash || stderr_hash || returncode)
        for each verification
    ])))

    This ensures R_t is COUPLED to real Lean execution artifacts.
    """
    leaf_hashes = []
    for lr in lean_results:
        # Each leaf combines all Lean artifacts
        leaf_data = f"{lr.lean_source_hash}:{lr.stdout_hash}:{lr.stderr_hash}:{lr.returncode}"
        leaf_hash = hashlib.sha256(leaf_data.encode("utf-8")).hexdigest()
        leaf_hashes.append(leaf_hash)

    # Sort for determinism
    leaf_hashes.sort()

    if leaf_hashes:
        concat = "".join(leaf_hashes)
        return hashlib.sha256(concat.encode("ascii")).hexdigest()
    else:
        return hashlib.sha256(b"REASONING:EMPTY").hexdigest()


def compute_ui_root(seed: int, statements: List[str]) -> tuple[str, str]:
    """
    Compute U_t (UI root) from deterministic UI event.

    Returns (U_t, ui_event_hash)
    """
    # Create deterministic UI event payload
    ui_payload = {
        "action": "verify_statements",
        "seed": seed,
        "statements": sorted(statements),
        "event_type": "verification_request",
    }

    # Canonical JSON serialization
    ui_json = json.dumps(ui_payload, separators=(",", ":"), sort_keys=True)
    ui_event_hash = hashlib.sha256(ui_json.encode("utf-8")).hexdigest()

    # U_t is the UI event hash
    return ui_event_hash, ui_event_hash


def compute_composite_root(r_t: str, u_t: str) -> str:
    """
    Compute H_t = SHA256(R_t || U_t)

    This is the composite attestation root that proves:
    1. Reasoning artifacts (R_t) - from Lean verification
    2. UI artifacts (U_t) - from user interaction
    """
    composite_data = f"{r_t}{u_t}".encode("ascii")
    return hashlib.sha256(composite_data).hexdigest()


def run_lean_coupled_pipeline(
    seed: int,
    statements: List[str],
    is_mock_mode: bool,
) -> LeanCoupledPipelineResult:
    """
    Run the full Lean-coupled pipeline.

    In enabled mode:
        - Runs REAL Lean verification on each statement
        - Computes R_t from REAL Lean artifacts
        - H_t is coupled to actual Lean execution

    In mock mode:
        - Uses synthetic artifacts (no real Lean)
        - H_t is computed from mock data
    """
    from backend.lean_mode import (
        get_build_runner,
        is_mock_abstention,
        LeanMode,
    )

    project_dir = get_lean_project_dir()
    jobs_dir = ensure_jobs_dir()

    # Get build runner based on mode
    build_runner = get_build_runner(
        project_dir=project_dir,
        timeout=90,
    )

    # Run Lean verification on all statements
    lean_results: List[LeanVerificationResult] = []
    for stmt in statements:
        result = run_lean_verification_single(
            statement=stmt,
            jobs_dir=jobs_dir,
            project_dir=project_dir,
            build_runner=build_runner,
            is_mock_check=is_mock_abstention,
        )
        lean_results.append(result)

    # Check if real Lean ran (not mock)
    lean_ran = all(not lr.is_mock for lr in lean_results)

    # Compute R_t from Lean artifacts
    R_t = compute_reasoning_root(lean_results)

    # Compute U_t from UI event
    U_t, ui_event_hash = compute_ui_root(seed, statements)

    # Compute H_t = SHA256(R_t || U_t)
    H_t = compute_composite_root(R_t, U_t)

    # Generate deterministic run ID
    run_data = f"{seed}:{H_t}"
    run_id = hashlib.sha256(run_data.encode("utf-8")).hexdigest()[:16]

    return LeanCoupledPipelineResult(
        lean_results=lean_results,
        lean_ran=lean_ran,
        R_t=R_t,
        U_t=U_t,
        H_t=H_t,
        ui_event_hash=ui_event_hash,
        seed=seed,
        run_id=run_id,
    )


def verify_core_loop(
    seed: int = 42,
    runs: int = 2,
    verbose: bool = False,
) -> Dict[str, Any]:
    """
    Run the Lean-coupled pipeline N times and verify determinism.

    This function:
    1. Verifies Lean is available (fails if not, unless ML_LEAN_MODE=mock)
    2. Runs the REAL Lean-coupled pipeline N times
    3. Computes H_t from REAL Lean artifacts
    4. Compares H_t values for determinism

    Args:
        seed: Deterministic seed for all runs
        runs: Number of runs to execute (minimum 2)
        verbose: If True, include run details in output

    Returns:
        JSON-serializable verdict dictionary
    """
    # Step 1: Verify Lean is available
    lean_status = verify_lean_available()
    if lean_status["error"]:
        return {
            "deterministic": False,
            "error": lean_status["error"],
            "hint": "Run 'make lean-setup' to install Lean, or set ML_LEAN_MODE=mock for testing",
            "runs": 0,
            "mode": "standalone",
            "lean": "unavailable",
        }

    is_mock_mode = lean_status["is_mock"]
    runs = max(runs, 2)  # Minimum 2 runs to compare

    # Step 2: Run Lean-coupled pipeline N times
    results: List[Dict[str, Any]] = []
    h_t_values: List[str] = []
    pipeline_results: List[LeanCoupledPipelineResult] = []

    for i in range(runs):
        try:
            pipeline = run_lean_coupled_pipeline(
                seed=seed,
                statements=TEST_STATEMENTS,
                is_mock_mode=is_mock_mode,
            )
            pipeline_results.append(pipeline)
            h_t_values.append(pipeline.H_t)

            # Build run info
            run_info: Dict[str, Any] = {
                "run": i + 1,
                "H_t": pipeline.H_t,
                "R_t": pipeline.R_t,
                "U_t": pipeline.U_t,
                "run_id": pipeline.run_id,
                "lean_ran": pipeline.lean_ran,
            }

            # Add Lean artifact proof (only present if Lean ran)
            if pipeline.lean_ran:
                # Include Lean-specific artifacts that prove Lean executed
                run_info["lean_proof"] = {
                    "statements_verified": len(pipeline.lean_results),
                    "all_succeeded": all(lr.success for lr in pipeline.lean_results),
                    "total_duration_ms": sum(lr.duration_ms for lr in pipeline.lean_results),
                    "artifact_hashes": [
                        {
                            "statement": lr.statement,
                            "lean_source_hash": lr.lean_source_hash,
                            "stdout_hash": lr.stdout_hash,
                            "stderr_hash": lr.stderr_hash,
                            "returncode": lr.returncode,
                        }
                        for lr in pipeline.lean_results
                    ],
                }

            results.append(run_info)

            if verbose:
                mode_str = "LEAN" if pipeline.lean_ran else "MOCK"
                print(f"Run {i + 1} [{mode_str}]: H_t = {pipeline.H_t[:16]}...", file=sys.stderr)

        except Exception as e:
            return {
                "deterministic": False,
                "error": str(e),
                "traceback": traceback.format_exc(),
                "runs": i,
                "mode": "standalone",
                "lean": lean_status["effective_mode"],
            }

    # Step 3: Check if all H_t values are identical
    first_h_t = h_t_values[0]
    deterministic = all(h == first_h_t for h in h_t_values)

    # Determine lean status string based on actual execution
    first_pipeline = pipeline_results[0]
    if first_pipeline.lean_ran:
        lean_str = "enabled"
    elif is_mock_mode:
        lean_str = "mock"
    else:
        lean_str = "disabled"

    verdict: Dict[str, Any] = {
        "deterministic": deterministic,
        "runs": runs,
        "H_t": first_h_t,
        "mode": "standalone",
        "lean": lean_str,
    }

    # Include Lean verification proof if Lean ran
    if first_pipeline.lean_ran:
        verdict["lean_verification"] = {
            "statements": TEST_STATEMENTS,
            "statements_count": len(TEST_STATEMENTS),
            "all_verified": all(lr.success for lr in first_pipeline.lean_results),
            "total_duration_ms": sum(lr.duration_ms for lr in first_pipeline.lean_results),
            # R_t derivation proof - shows H_t is Lean-coupled
            "R_t_derivation": {
                "method": "SHA256(concat(sorted(leaf_hashes)))",
                "leaf_count": len(first_pipeline.lean_results),
                "leaf_formula": "SHA256(lean_source_hash:stdout_hash:stderr_hash:returncode)",
            },
        }

    if verbose or not deterministic:
        verdict["details"] = {
            "seed": seed,
            "h_t_values": h_t_values,
            "all_match": deterministic,
            "lean_status": lean_status,
        }

    if not deterministic:
        # Find first mismatch
        for i, h in enumerate(h_t_values):
            if h != first_h_t:
                verdict["mismatch"] = {
                    "run": i + 1,
                    "expected": first_h_t,
                    "actual": h,
                }
                break

    if verbose:
        verdict["run_details"] = results

    return verdict


def main() -> int:
    """CLI entry point."""
    parser = argparse.ArgumentParser(
        description="Verify MathLedger core loop determinism with REAL Lean verification",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python scripts/verify_core_loop.py                  # Basic verification (2 runs, real Lean)
  python scripts/verify_core_loop.py --seed 42        # Specific seed
  python scripts/verify_core_loop.py --runs 5         # More runs for confidence
  python scripts/verify_core_loop.py --verbose        # Detailed output

Mock mode (for testing without Lean):
  ML_LEAN_MODE=mock python scripts/verify_core_loop.py

Exit codes:
  0 = Deterministic (all H_t match, Lean verified)
  1 = Non-deterministic (H_t mismatch)
  2 = Execution error (including Lean unavailable)

LEAN COUPLING:
  In enabled mode, H_t is computed from REAL Lean artifacts:
    R_t = SHA256(concat(sorted([SHA256(lean_source_hash:stdout_hash:stderr_hash:returncode)])))
    U_t = SHA256(ui_event_payload)
    H_t = SHA256(R_t || U_t)

  The "lean_proof" field in verbose output contains artifacts that could
  only exist if Lean actually ran (stdout_hash, stderr_hash, duration_ms).
""",
    )
    parser.add_argument(
        "--seed",
        type=int,
        default=42,
        help="Deterministic seed for runs (default: 42)",
    )
    parser.add_argument(
        "--runs",
        type=int,
        default=2,
        help="Number of runs to compare (default: 2, minimum: 2)",
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Include detailed run information in output",
    )
    parser.add_argument(
        "--pretty",
        action="store_true",
        help="Pretty-print JSON output (default: compact)",
    )

    args = parser.parse_args()

    try:
        verdict = verify_core_loop(
            seed=args.seed,
            runs=args.runs,
            verbose=args.verbose,
        )

        # Output JSON verdict
        if args.pretty:
            output = json.dumps(verdict, indent=2, sort_keys=True)
        else:
            output = json.dumps(verdict, separators=(",", ":"), sort_keys=True)

        print(output)

        # Exit code based on determinism and Lean status
        if "error" in verdict:
            return 2
        if verdict.get("lean") == "unavailable":
            return 2
        return 0 if verdict["deterministic"] else 1

    except ImportError as e:
        error_verdict = {
            "deterministic": False,
            "error": f"Import error: {e}",
            "hint": "Run 'uv sync' to install dependencies",
            "runs": 0,
            "mode": "standalone",
            "lean": "unknown",
        }
        print(json.dumps(error_verdict, separators=(",", ":")))
        return 2

    except Exception as e:
        error_verdict = {
            "deterministic": False,
            "error": str(e),
            "traceback": traceback.format_exc(),
            "runs": 0,
            "mode": "standalone",
            "lean": "unknown",
        }
        print(json.dumps(error_verdict, separators=(",", ":")))
        return 2


if __name__ == "__main__":
    sys.exit(main())
