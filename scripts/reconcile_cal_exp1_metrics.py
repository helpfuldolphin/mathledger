#!/usr/bin/env python3
"""
CAL-EXP-1 Metric Reconciliation Script

This script loads canonical artifacts and prints reconciled metrics
for BASELINE vs UPGRADE-1 comparison.

Purpose: Resolve discrepancy between conflicting assessment reports.
"""

import json
from pathlib import Path
from typing import Dict, Any, List

# Canonical artifact paths
ARTIFACTS = {
    "baseline_seed42": "results/p5_cal_exp1/synthetic_seed42/cal_exp1_20251212_091922/cal_exp1_report.json",
    "baseline_seed43": "results/p5_cal_exp1/synthetic_seed43/cal_exp1_20251212_091945/cal_exp1_report.json",
    "upgrade1_seed42": "results/p5_cal_exp1/upgrade1_seed42/cal_exp1_20251212_095143/cal_exp1_report.json",
    "upgrade1_seed43": "results/p5_cal_exp1/upgrade1_seed43/cal_exp1_20251212_095159/cal_exp1_report.json",
}

def load_artifact(path: str) -> Dict[str, Any]:
    """Load JSON artifact."""
    with open(path, 'r') as f:
        return json.load(f)

def extract_window_metrics(data: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Extract per-window metrics from artifact."""
    return data.get("windows", [])

def compute_aggregate_metrics(windows: List[Dict[str, Any]]) -> Dict[str, float]:
    """Compute aggregate metrics across windows."""
    if not windows:
        return {}

    n = len(windows)

    # Mean of mean_delta_p
    mean_delta_p_values = [w["mean_delta_p"] for w in windows]
    mean_of_mean_delta_p = sum(mean_delta_p_values) / n

    # Mean of delta_bias
    delta_bias_values = [w["delta_bias"] for w in windows]
    mean_delta_bias = sum(delta_bias_values) / n

    # Mean of divergence_rate
    div_rate_values = [w["divergence_rate"] for w in windows]
    mean_div_rate = sum(div_rate_values) / n

    # Mean of phase_lag_xcorr
    phase_lag_values = [w["phase_lag_xcorr"] for w in windows]
    mean_phase_lag = sum(phase_lag_values) / n

    # Slope of mean_delta_p (linear trend)
    if n > 1:
        x_mean = (n - 1) / 2
        y_mean = mean_of_mean_delta_p
        numerator = sum((i - x_mean) * (mean_delta_p_values[i] - y_mean) for i in range(n))
        denominator = sum((i - x_mean) ** 2 for i in range(n))
        slope = numerator / denominator if denominator != 0 else 0.0
    else:
        slope = 0.0

    return {
        "mean_of_mean_delta_p": mean_of_mean_delta_p,
        "mean_delta_bias": mean_delta_bias,
        "mean_divergence_rate": mean_div_rate,
        "mean_phase_lag": mean_phase_lag,
        "slope_mean_delta_p": slope,
        "final_divergence_rate": div_rate_values[-1] if div_rate_values else 0.0,
        "final_delta_bias": delta_bias_values[-1] if delta_bias_values else 0.0,
    }

def main():
    print("=" * 80)
    print("CAL-EXP-1 METRIC RECONCILIATION")
    print("=" * 80)
    print()

    # Load all artifacts
    artifacts = {}
    for name, path in ARTIFACTS.items():
        full_path = Path(__file__).parent.parent / path
        print(f"Loading: {name}")
        print(f"  Path: {path}")
        artifacts[name] = load_artifact(full_path)
        print(f"  Schema: {artifacts[name].get('schema_version', 'N/A')}")
        print(f"  Run ID: {artifacts[name].get('run_id', 'N/A')}")
        print(f"  Windows: {len(artifacts[name].get('windows', []))}")
        if 'upgrade_config' in artifacts[name]:
            print(f"  Upgrade: {artifacts[name]['upgrade_config'].get('label', 'N/A')}")
            print(f"  LR Overrides: {artifacts[name]['upgrade_config'].get('lr_overrides', 'None')}")
        print()

    print("=" * 80)
    print("CANONICAL METRIC DEFINITIONS")
    print("=" * 80)
    print()
    print("Source: cal_exp1_report.json (generated by scripts/run_p5_cal_exp1.py)")
    print()
    print("Field paths:")
    print("  divergence_rate := windows[i].divergence_rate")
    print("    Definition: Fraction of cycles where is_diverged()=True")
    print("    is_diverged() := abs(delta_p) > 0.05 (hardcoded threshold)")
    print("    Type: 'any divergence' (not decomposed by success/omega/blocked)")
    print()
    print("  mean_delta_p := windows[i].mean_delta_p")
    print("    Definition: Mean of abs(delta_p) over window cycles")
    print("    delta_p := abs(divergence_snapshot.delta_p)")
    print("    Note: This is a MAGNITUDE, not signed")
    print()
    print("  delta_bias := windows[i].delta_bias")
    print("    Definition: mean_delta_p * (0.5 - divergence_rate)")
    print("    Note: This is a HEURISTIC proxy, not true signed bias")
    print("    WARNING: This formula conflates magnitude with direction")
    print()
    print("  phase_lag_xcorr := windows[i].phase_lag_xcorr")
    print("    Definition: Lag-1 autocorrelation of delta_p series")
    print()
    print("CRITICAL OBSERVATION:")
    print("  The 'delta_bias' field is NOT true bias (Twin - Real).")
    print("  It's a heuristic: mean_delta_p * (0.5 - divergence_rate)")
    print("  When divergence_rate=1.0, delta_bias = -0.5 * mean_delta_p")
    print("  This explains why 'bias' tracks mean_delta_p inversely.")
    print()

    print("=" * 80)
    print("PER-WINDOW METRICS FROM CANONICAL ARTIFACTS")
    print("=" * 80)
    print()

    for name, data in artifacts.items():
        print(f"--- {name} ---")
        windows = extract_window_metrics(data)
        for w in windows:
            print(f"  Window {w['window_index']}: "
                  f"div_rate={w['divergence_rate']:.4f}, "
                  f"mean_delta_p={w['mean_delta_p']:.6f}, "
                  f"delta_bias={w['delta_bias']:.6f}, "
                  f"phase_lag={w['phase_lag_xcorr']:.6f}, "
                  f"pattern={w['pattern_tag']}")
        print()

    print("=" * 80)
    print("AGGREGATE METRICS (computed from canonical artifacts)")
    print("=" * 80)
    print()

    aggregates = {}
    for name, data in artifacts.items():
        windows = extract_window_metrics(data)
        aggregates[name] = compute_aggregate_metrics(windows)

    # Print comparison table
    print("SEED=42 COMPARISON:")
    print(f"{'Metric':<30} {'BASELINE':>15} {'UPGRADE-1':>15} {'Delta':>15}")
    print("-" * 75)
    b42 = aggregates["baseline_seed42"]
    u42 = aggregates["upgrade1_seed42"]
    for key in b42:
        delta = u42[key] - b42[key]
        print(f"{key:<30} {b42[key]:>15.6f} {u42[key]:>15.6f} {delta:>+15.6f}")
    print()

    print("SEED=43 COMPARISON:")
    print(f"{'Metric':<30} {'BASELINE':>15} {'UPGRADE-1':>15} {'Delta':>15}")
    print("-" * 75)
    b43 = aggregates["baseline_seed43"]
    u43 = aggregates["upgrade1_seed43"]
    for key in b43:
        delta = u43[key] - b43[key]
        print(f"{key:<30} {b43[key]:>15.6f} {u43[key]:>15.6f} {delta:>+15.6f}")
    print()

    print("=" * 80)
    print("DIVERGENCE DECOMPOSITION CHECK")
    print("=" * 80)
    print()
    print("Checking for success/omega/blocked/state decomposition in artifacts...")

    # Check if decomposition exists
    for name, data in artifacts.items():
        has_decomposition = False
        # Check windows for decomposition fields
        for w in data.get("windows", []):
            if any(k in w for k in ["success_divergences", "omega_divergences", "blocked_divergences", "state_divergences"]):
                has_decomposition = True
                break
        print(f"  {name}: decomposition {'AVAILABLE' if has_decomposition else 'NOT AVAILABLE'}")

    print()
    print("Conclusion: Divergence decomposition is NOT available in cal_exp1_report.json")
    print("The harness computes only aggregate 'any divergence' rate.")
    print()

    print("=" * 80)
    print("RECONCILIATION FINDINGS")
    print("=" * 80)
    print()

    # Key finding: mean_delta_p trend
    print("Q: Did mean_delta_p improve with UPGRADE-1?")
    print()

    # Seed 42
    delta_42 = u42["mean_of_mean_delta_p"] - b42["mean_of_mean_delta_p"]
    print(f"  Seed=42: BASELINE mean_delta_p = {b42['mean_of_mean_delta_p']:.6f}")
    print(f"           UPGRADE-1 mean_delta_p = {u42['mean_of_mean_delta_p']:.6f}")
    print(f"           Delta = {delta_42:+.6f} ({'IMPROVED' if delta_42 < 0 else 'WORSENED'})")
    print()

    # Seed 43
    delta_43 = u43["mean_of_mean_delta_p"] - b43["mean_of_mean_delta_p"]
    print(f"  Seed=43: BASELINE mean_delta_p = {b43['mean_of_mean_delta_p']:.6f}")
    print(f"           UPGRADE-1 mean_delta_p = {u43['mean_of_mean_delta_p']:.6f}")
    print(f"           Delta = {delta_43:+.6f} ({'IMPROVED' if delta_43 < 0 else 'WORSENED'})")
    print()

    print("Q: Why does divergence_rate stay at 1.0?")
    print()
    print("  Answer: The divergence threshold is 0.05.")
    print(f"  Seed=42 mean_delta_p range: {min(w['mean_delta_p'] for w in extract_window_metrics(artifacts['baseline_seed42'])):.4f} - {max(w['mean_delta_p'] for w in extract_window_metrics(artifacts['baseline_seed42'])):.4f}")
    print(f"  Seed=43 mean_delta_p range: {min(w['mean_delta_p'] for w in extract_window_metrics(artifacts['baseline_seed43'])):.4f} - {max(w['mean_delta_p'] for w in extract_window_metrics(artifacts['baseline_seed43'])):.4f}")
    print("  Since mean_delta_p ~ 0.045-0.065 consistently exceeds 0.05,")
    print("  divergence_rate will remain at or near 1.0 regardless of LR tuning.")
    print()
    print("  The 0.05 threshold is structurally too tight for this noise regime.")
    print("  However, per doctrine, we do NOT adjust thresholds during calibration.")
    print()

    print("=" * 80)
    print("VERDICT")
    print("=" * 80)
    print()

    # Final assessment
    improved_count = 0
    if delta_42 < 0:
        improved_count += 1
    if delta_43 < 0:
        improved_count += 1

    if improved_count == 2:
        print("ASSESSMENT: UPGRADE-1 IMPROVED mean_delta_p in BOTH seeds")
        print("DECISION: PROCEED to controlled parameter sweep (still CAL-EXP-1)")
    elif improved_count == 1:
        print("ASSESSMENT: UPGRADE-1 MIXED results (1 improved, 1 worsened)")
        print("DECISION: ADJUST - propose minimal LR sweep before CAL-EXP-2")
    else:
        print("ASSESSMENT: UPGRADE-1 WORSENED mean_delta_p in BOTH seeds")
        print("DECISION: ADJUST - propose minimal LR sweep before CAL-EXP-2")

    print()
    print("=" * 80)

if __name__ == "__main__":
    main()
