"""
Wide Slice Dyno Chart Log Validation Tests
===========================================

This module validates the structure of Wide Slice experiment JSONL log files
generated by run_wide_slice_experiments.ps1.

Test Purpose:
    - Verify log shape and required fields for baseline and RFL experiments
    - Validate that each JSONL line contains expected structure for Dyno Chart visualization
    - Skip gracefully if log files don't exist yet

Test Modes:
    - WIDE_SLICE: Run with `pytest -m wide_slice` or `WIDE_SLICE_TESTS=true`
    - These tests do NOT require DB/Redis - they only validate file structure
    
    Note: WIDE_SLICE tests are separate from SPARK (First Organism) tests:
    - SPARK tests = First Organism closed loop validation (marked with @pytest.mark.first_organism)
    - WIDE_SLICE tests = Dyno Chart log validation (marked with @pytest.mark.wide_slice)

Expected Files:
    - results/fo_baseline_wide.jsonl: Baseline experiment logs
    - results/fo_rfl_wide.jsonl: RFL experiment logs

Usage:
    WIDE_SLICE_TESTS=true pytest tests/integration/test_wide_slice_logs.py -v
    pytest -m wide_slice -v
"""

from __future__ import annotations

import json
from pathlib import Path
from typing import Any, Dict, List, Optional

import pytest


# Expected file paths
BASELINE_WIDE_LOG = Path("results/fo_baseline_wide.jsonl")
RFL_WIDE_LOG = Path("results/fo_rfl_wide.jsonl")


def _read_jsonl_lines(file_path: Path) -> List[Dict[str, Any]]:
    """
    Read and parse JSONL file, returning list of JSON objects.
    
    Args:
        file_path: Path to JSONL file
        
    Returns:
        List of parsed JSON objects
        
    Raises:
        FileNotFoundError: If file doesn't exist
        json.JSONDecodeError: If any line is invalid JSON
    """
    if not file_path.exists():
        raise FileNotFoundError(f"File not found: {file_path}")
    
    records = []
    with open(file_path, "r", encoding="utf-8") as f:
        for line_num, line in enumerate(f, start=1):
            line = line.strip()
            if not line:
                continue
            try:
                records.append(json.loads(line))
            except json.JSONDecodeError as e:
                raise json.JSONDecodeError(
                    f"Invalid JSON on line {line_num} of {file_path}: {e.msg}",
                    e.doc,
                    e.pos,
                ) from e
    
    return records


def _validate_log_record_shape(record: Dict[str, Any], file_name: str, line_num: int) -> List[str]:
    """
    Validate that a log record has the expected shape for Dyno Chart.
    
    This validates against the ACTUAL schema produced by run_fo_cycles.py:
    - cycle (int): Cycle number
    - slice_name (str): Name of the curriculum slice
    - status (str): Status of the cycle (e.g., "abstain", "verified", "error")
    - method (str): Method used for verification (e.g., "lean-disabled")
    - abstention (bool) OR is_abstention (bool): Whether this cycle abstained
      (run_fo_cycles.py uses "abstention", but we accept both for compatibility)
    
    Args:
        record: JSON record to validate
        file_name: Name of the source file (for error messages)
        line_num: Line number in the file (for error messages)
        
    Returns:
        List of validation error messages (empty if valid)
    """
    errors = []
    
    # Required: cycle (int)
    if "cycle" not in record:
        errors.append(f"{file_name}:{line_num}: missing required field 'cycle'")
    elif not isinstance(record["cycle"], int):
        errors.append(f"{file_name}:{line_num}: 'cycle' must be int, got {type(record['cycle']).__name__}")
    
    # Required: slice_name (str)
    if "slice_name" not in record:
        errors.append(f"{file_name}:{line_num}: missing required field 'slice_name'")
    elif not isinstance(record["slice_name"], str):
        errors.append(f"{file_name}:{line_num}: 'slice_name' must be str, got {type(record['slice_name']).__name__}")
    
    # Required: status (str)
    if "status" not in record:
        errors.append(f"{file_name}:{line_num}: missing required field 'status'")
    elif not isinstance(record["status"], str):
        errors.append(f"{file_name}:{line_num}: 'status' must be str, got {type(record['status']).__name__}")
    
    # Required: method (str) - run_fo_cycles.py always includes this
    if "method" not in record:
        errors.append(f"{file_name}:{line_num}: missing required field 'method'")
    elif not isinstance(record["method"], str):
        errors.append(f"{file_name}:{line_num}: 'method' must be str, got {type(record['method']).__name__}")
    
    # Required: abstention (bool) OR is_abstention (bool) - accept both for compatibility
    has_abstention = "abstention" in record
    has_is_abstention = "is_abstention" in record
    if not has_abstention and not has_is_abstention:
        # Allow derivation from status field
        if "status" in record:
            status = record["status"].lower()
            if status in ("abstain", "abstention", "abstained"):
                # Coherent derivation: status indicates abstention
                pass  # Acceptable
            else:
                errors.append(f"{file_name}:{line_num}: missing 'abstention' or 'is_abstention' field (cannot derive from status={status})")
        else:
            errors.append(f"{file_name}:{line_num}: missing required field 'abstention' or 'is_abstention'")
    elif has_abstention and not isinstance(record["abstention"], bool):
        errors.append(f"{file_name}:{line_num}: 'abstention' must be bool, got {type(record['abstention']).__name__}")
    elif has_is_abstention and not isinstance(record["is_abstention"], bool):
        errors.append(f"{file_name}:{line_num}: 'is_abstention' must be bool, got {type(record['is_abstention']).__name__}")
    
    return errors


@pytest.mark.wide_slice
def test_wide_slice_baseline_log_shape():
    """
    Validate the structure of baseline Wide Slice JSONL log file.
    
    This test verifies that each line in results/fo_baseline_wide.jsonl contains:
    - cycle (int)
    - slice_name (str)
    - status (str)
    - method (str)
    - abstention (bool) or is_abstention (bool)
    
    Note: This validates against the schema produced by run_fo_cycles.py.
    If the file doesn't exist, it means Wide Slice experiments haven't been run yet.
    
    Skips gracefully if the file doesn't exist yet.
    """
    if not BASELINE_WIDE_LOG.exists():
        pytest.skip(
            "[SKIP] Wide Slice logs not found; run run_wide_slice_experiments.ps1 first. "
            f"Expected: {BASELINE_WIDE_LOG}"
        )
    
    try:
        records = _read_jsonl_lines(BASELINE_WIDE_LOG)
    except FileNotFoundError:
        pytest.skip(
            "[SKIP] Wide Slice logs not found; run run_wide_slice_experiments.ps1 first. "
            f"Expected: {BASELINE_WIDE_LOG}"
        )
    
    assert len(records) > 0, f"Baseline log file {BASELINE_WIDE_LOG} is empty"
    
    all_errors = []
    for line_num, record in enumerate(records, start=1):
        errors = _validate_log_record_shape(record, BASELINE_WIDE_LOG.name, line_num)
        all_errors.extend(errors)
    
    if all_errors:
        error_msg = "\n".join(all_errors)
        pytest.fail(f"Baseline log validation failed:\n{error_msg}")
    
    # Additional sanity check: cycles should be sequential or at least non-decreasing
    cycles = [r.get("cycle") for r in records if "cycle" in r]
    if len(cycles) > 1:
        # Allow non-decreasing cycles (may have gaps)
        for i in range(1, len(cycles)):
            if cycles[i] < cycles[i - 1]:
                pytest.fail(
                    f"Baseline log has non-monotonic cycles: line {i+1} has cycle={cycles[i]}, "
                    f"previous line has cycle={cycles[i-1]}"
                )


@pytest.mark.wide_slice
def test_wide_slice_rfl_log_shape():
    """
    Validate the structure of RFL Wide Slice JSONL log file.
    
    This test verifies that each line in results/fo_rfl_wide.jsonl contains:
    - cycle (int)
    - slice_name (str)
    - status (str)
    - method (str)
    - abstention (bool) or is_abstention (bool)
    
    Note: This validates against the schema produced by run_fo_cycles.py.
    If the file doesn't exist, it means Wide Slice experiments haven't been run yet.
    
    Skips gracefully if the file doesn't exist yet.
    """
    if not RFL_WIDE_LOG.exists():
        pytest.skip(
            "[SKIP] Wide Slice logs not found; run run_wide_slice_experiments.ps1 first. "
            f"Expected: {RFL_WIDE_LOG}"
        )
    
    try:
        records = _read_jsonl_lines(RFL_WIDE_LOG)
    except FileNotFoundError:
        pytest.skip(
            "[SKIP] Wide Slice logs not found; run run_wide_slice_experiments.ps1 first. "
            f"Expected: {RFL_WIDE_LOG}"
        )
    
    assert len(records) > 0, f"RFL log file {RFL_WIDE_LOG} is empty"
    
    all_errors = []
    for line_num, record in enumerate(records, start=1):
        errors = _validate_log_record_shape(record, RFL_WIDE_LOG.name, line_num)
        all_errors.extend(errors)
    
    if all_errors:
        error_msg = "\n".join(all_errors)
        pytest.fail(f"RFL log validation failed:\n{error_msg}")
    
    # Additional sanity check: cycles should be sequential or at least non-decreasing
    cycles = [r.get("cycle") for r in records if "cycle" in r]
    if len(cycles) > 1:
        # Allow non-decreasing cycles (may have gaps)
        for i in range(1, len(cycles)):
            if cycles[i] < cycles[i - 1]:
                pytest.fail(
                    f"RFL log has non-monotonic cycles: line {i+1} has cycle={cycles[i]}, "
                    f"previous line has cycle={cycles[i-1]}"
                )


@pytest.mark.wide_slice
def test_wide_slice_logs_exist():
    """
    Verify that at least one Wide Slice log file exists.
    
    This is a convenience test to check if experiments have been run.
    Skips if neither file exists.
    """
    baseline_exists = BASELINE_WIDE_LOG.exists()
    rfl_exists = RFL_WIDE_LOG.exists()
    
    if not baseline_exists and not rfl_exists:
        pytest.skip(
            "[SKIP] Wide Slice logs not found; run run_wide_slice_experiments.ps1 first. "
            f"Expected: {BASELINE_WIDE_LOG} or {RFL_WIDE_LOG}"
        )
    
    # If we get here, at least one file exists (test passes)
    assert baseline_exists or rfl_exists


@pytest.mark.wide_slice
def test_wide_slice_logs_are_valid_jsonl():
    """
    Verify that Wide Slice log files are valid JSONL format.
    
    This test ensures the files can be parsed as JSONL without syntax errors.
    Skips if files don't exist.
    """
    files_to_check = []
    if BASELINE_WIDE_LOG.exists():
        files_to_check.append(BASELINE_WIDE_LOG)
    if RFL_WIDE_LOG.exists():
        files_to_check.append(RFL_WIDE_LOG)
    
    if not files_to_check:
        pytest.skip(
            "[SKIP] Wide Slice logs not found; run run_wide_slice_experiments.ps1 first."
        )
    
    for file_path in files_to_check:
        try:
            records = _read_jsonl_lines(file_path)
            assert len(records) > 0, f"{file_path} is empty"
        except json.JSONDecodeError as e:
            pytest.fail(f"{file_path} contains invalid JSON: {e}")
        except Exception as e:
            pytest.fail(f"{file_path} failed to parse: {e}")

