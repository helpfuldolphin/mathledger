from backend.axiom_engine.derive import derive, Rule, IMPLIES
from backend.axiom_engine.model import Statement
from datetime import datetime
import hashlib

def test_derive_fixed_point_and_determinism(db_session):
    system_id = 1
    # Given: p, p -> q, p -> r
    s1 = Statement(
        system_id=system_id,
        normalized_text="p",
        hash=hashlib.sha256("p".encode()).hexdigest(),
        created_at=datetime.now()
    )
    s2 = Statement(
        system_id=system_id,
        normalized_text=f"p {IMPLIES} q",
        hash=hashlib.sha256(f"p {IMPLIES} q".encode()).hexdigest(),
        created_at=datetime.now()
    )
    s3 = Statement(
        system_id=system_id,
        normalized_text=f"p {IMPLIES} r",
        hash=hashlib.sha256(f"p {IMPLIES} r".encode()).hexdigest(),
        created_at=datetime.now()
    )
    db_session.add_all([s1, s2, s3])
    db_session.commit()

    results = []
    for _ in range(2):
        # Clear the database for a clean pass
        db_session.query(Statement).delete()
        db_session.commit()

        # re-seed for a clean pass
        s1 = Statement(
            system_id=system_id,
            normalized_text="p",
            hash=hashlib.sha256("p".encode()).hexdigest(),
            created_at=datetime.now()
        )
        s2 = Statement(
            system_id=system_id,
            normalized_text=f"p {IMPLIES} q",
            hash=hashlib.sha256(f"p {IMPLIES} q".encode()).hexdigest(),
            created_at=datetime.now()
        )
        s3 = Statement(
            system_id=system_id,
            normalized_text=f"p {IMPLIES} r",
            hash=hashlib.sha256(f"p {IMPLIES} r".encode()).hexdigest(),
            created_at=datetime.now()
        )
        db_session.add_all([s1, s2, s3])
        db_session.commit()

        derive(db_session, system_id, steps=1, breadth_cap=10, total_cap=100)

        derived = db_session.query(Statement).filter(
            Statement.derivation_rule == "modus_ponens"
        ).order_by(Statement.content_norm).all()

        results.append([s.normalized_text for s in derived])

    assert sorted(results[0]) == ["q", "r"]
    assert results[0] == results[1], "Derivation order should be deterministic"
